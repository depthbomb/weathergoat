diff --git a/node_modules/croner/.1fdaff7fafffdfcd-00000002.croner.min.js b/.1fdaff7fafffdfcd-00000002.croner.min.js
new file mode 100644
index 0000000000000000000000000000000000000000..5d975bb9bb2bd88f5d753b1b4c3345c34be71e6c
--- /dev/null
+++ b/.1fdaff7fafffdfcd-00000002.croner.min.js
@@ -0,0 +1 @@
+function minitz(y,m,d,h,i,s,tz,throwOnInvalid){return minitz.fromTZ(minitz.tp(y,m,d,h,i,s,tz),throwOnInvalid)}minitz.fromTZISO=(localTimeStr,tz,throwOnInvalid)=>{return minitz.fromTZ(parseISOLocal(localTimeStr,tz),throwOnInvalid)};minitz.fromTZ=function(tp,throwOnInvalid){const inDate=new Date(Date.UTC(tp.y,tp.m-1,tp.d,tp.h,tp.i,tp.s)),offset=getTimezoneOffset(tp.tz,inDate),dateGuess=new Date(inDate.getTime()-offset),dateOffsGuess=getTimezoneOffset(tp.tz,dateGuess);if(dateOffsGuess-offset===0){return dateGuess}else{const dateGuess2=new Date(inDate.getTime()-dateOffsGuess),dateOffsGuess2=getTimezoneOffset(tp.tz,dateGuess2);if(dateOffsGuess2-dateOffsGuess===0){return dateGuess2}else if(!throwOnInvalid&&dateOffsGuess2-dateOffsGuess>0){return dateGuess2}else if(!throwOnInvalid){return dateGuess}else{throw new Error("Invalid date passed to fromTZ()")}}};minitz.toTZ=function(d,tzStr){const localDateString=d.toLocaleString("en-US",{timeZone:tzStr}).replace(/[\u202f]/," ");const td=new Date(localDateString);return{y:td.getFullYear(),m:td.getMonth()+1,d:td.getDate(),h:td.getHours(),i:td.getMinutes(),s:td.getSeconds(),tz:tzStr}};minitz.tp=(y,m,d,h,i,s,tz)=>{return{y:y,m:m,d:d,h:h,i:i,s:s,tz:tz}};function getTimezoneOffset(timeZone,date=new Date){const tz=date.toLocaleString("en-US",{timeZone:timeZone,timeZoneName:"shortOffset"}).split(" ").slice(-1)[0];const dateString=date.toLocaleString("en-US").replace(/[\u202f]/," ");return Date.parse(`${dateString} GMT`)-Date.parse(`${dateString} ${tz}`)}function parseISOLocal(dtStr,tz){const pd=new Date(Date.parse(dtStr));if(isNaN(pd)){throw new Error("minitz: Invalid ISO8601 passed to parser.")}const stringEnd=dtStr.substring(9);if(dtStr.includes("Z")||stringEnd.includes("-")||stringEnd.includes("+")){return minitz.tp(pd.getUTCFullYear(),pd.getUTCMonth()+1,pd.getUTCDate(),pd.getUTCHours(),pd.getUTCMinutes(),pd.getUTCSeconds(),"Etc/UTC")}else{return minitz.tp(pd.getFullYear(),pd.getMonth()+1,pd.getDate(),pd.getHours(),pd.getMinutes(),pd.getSeconds(),tz)}}minitz.minitz=minitz;function CronOptions(options){if(options===void 0){options={}}delete options.name;options.legacyMode=options.legacyMode===void 0?true:options.legacyMode;options.paused=options.paused===void 0?false:options.paused;options.maxRuns=options.maxRuns===void 0?Infinity:options.maxRuns;options.catch=options.catch===void 0?false:options.catch;options.interval=options.interval===void 0?0:parseInt(options.interval,10);options.utcOffset=options.utcOffset===void 0?void 0:parseInt(options.utcOffset,10);options.unref=options.unref===void 0?false:options.unref;if(options.startAt){options.startAt=new CronDate(options.startAt,options.timezone)}if(options.stopAt){options.stopAt=new CronDate(options.stopAt,options.timezone)}if(options.interval!==null){if(isNaN(options.interval)){throw new Error("CronOptions: Supplied value for interval is not a number")}else if(options.interval<0){throw new Error("CronOptions: Supplied value for interval can not be negative")}}if(options.utcOffset!==void 0){if(isNaN(options.utcOffset)){throw new Error("CronOptions: Invalid value passed for utcOffset, should be number representing minutes offset from UTC.")}else if(options.utcOffset<-870||options.utcOffset>870){throw new Error("CronOptions: utcOffset out of bounds.")}if(options.utcOffset!==void 0&&options.timezone){throw new Error("CronOptions: Combining 'utcOffset' with 'timezone' is not allowed.")}}if(options.unref!==true&&options.unref!==false){throw new Error("CronOptions: Unref should be either true, false or undefined(false).")}return options}const LAST_OCCURRENCE=32;const ANY_OCCURRENCE=1|2|4|8|16|LAST_OCCURRENCE;const OCCURRENCE_BITMASKS=[1,2,4,16,16];function CronPattern(pattern,timezone){this.pattern=pattern;this.timezone=timezone;this.second=Array(60).fill(0);this.minute=Array(60).fill(0);this.hour=Array(24).fill(0);this.day=Array(31).fill(0);this.month=Array(12).fill(0);this.dayOfWeek=Array(7).fill(0);this.lastDayOfMonth=false;this.starDOM=false;this.starDOW=false;this.parse()}CronPattern.prototype.parse=function(){if(!(typeof this.pattern==="string"||this.pattern.constructor===String)){throw new TypeError("CronPattern: Pattern has to be of type string.")}if(this.pattern.indexOf("@")>=0)this.pattern=this.handleNicknames(this.pattern).trim();const parts=this.pattern.replace(/\s+/g," ").split(" ");if(parts.length<5||parts.length>6){throw new TypeError("CronPattern: invalid configuration format ('"+this.pattern+"'), exactly five or six space separated parts are required.")}if(parts.length===5){parts.unshift("0")}if(parts[3].indexOf("L")>=0){parts[3]=parts[3].replace("L","");this.lastDayOfMonth=true}if(parts[3]=="*"){this.starDOM=true}if(parts[4].length>=3)parts[4]=this.replaceAlphaMonths(parts[4]);if(parts[5].length>=3)parts[5]=this.replaceAlphaDays(parts[5]);if(parts[5]=="*"){this.starDOW=true}if(this.pattern.indexOf("?")>=0){const initDate=new CronDate(new Date,this.timezone).getDate(true);parts[0]=parts[0].replace("?",initDate.getSeconds());parts[1]=parts[1].replace("?",initDate.getMinutes());parts[2]=parts[2].replace("?",initDate.getHours());if(!this.starDOM)parts[3]=parts[3].replace("?",initDate.getDate());parts[4]=parts[4].replace("?",initDate.getMonth()+1);if(!this.starDOW)parts[5]=parts[5].replace("?",initDate.getDay())}this.throwAtIllegalCharacters(parts);this.partToArray("second",parts[0],0,1);this.partToArray("minute",parts[1],0,1);this.partToArray("hour",parts[2],0,1);this.partToArray("day",parts[3],-1,1);this.partToArray("month",parts[4],-1,1);this.partToArray("dayOfWeek",parts[5],0,ANY_OCCURRENCE);if(this.dayOfWeek[7]){this.dayOfWeek[0]=this.dayOfWeek[7]}};CronPattern.prototype.partToArray=function(type,conf,valueIndexOffset,defaultValue){const arr=this[type];const lastDayOfMonth=type==="day"&&this.lastDayOfMonth;if(conf===""&&!lastDayOfMonth)throw new TypeError("CronPattern: configuration entry "+type+" ("+conf+") is empty, check for trailing spaces.");if(conf==="*")return arr.fill(defaultValue);const split=conf.split(",");if(split.length>1){for(let i=0;i<split.length;i++){this.partToArray(type,split[i],valueIndexOffset,defaultValue)}}else if(conf.indexOf("-")!==-1&&conf.indexOf("/")!==-1){this.handleRangeWithStepping(conf,type,valueIndexOffset,defaultValue)}else if(conf.indexOf("-")!==-1){this.handleRange(conf,type,valueIndexOffset,defaultValue)}else if(conf.indexOf("/")!==-1){this.handleStepping(conf,type,valueIndexOffset,defaultValue)}else if(conf!==""){this.handleNumber(conf,type,valueIndexOffset,defaultValue)}};CronPattern.prototype.throwAtIllegalCharacters=function(parts){for(let i=0;i<parts.length;i++){const reValidCron=i===5?/[^/*0-9,\-#L]+/:/[^/*0-9,-]+/;if(reValidCron.test(parts[i])){throw new TypeError("CronPattern: configuration entry "+i+" ("+parts[i]+") contains illegal characters.")}}};CronPattern.prototype.handleNumber=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const i=parseInt(result[0],10)+valueIndexOffset;if(isNaN(i)){throw new TypeError("CronPattern: "+type+" is not a number: '"+conf+"'")}this.setPart(type,i,result[1]||defaultValue)};CronPattern.prototype.setPart=function(part,index,value){if(!Object.prototype.hasOwnProperty.call(this,part)){throw new TypeError("CronPattern: Invalid part specified: "+part)}if(part==="dayOfWeek"){if(index===7)index=0;if((index<0||index>6)&&index!=="L"){throw new RangeError("CronPattern: Invalid value for dayOfWeek: "+index)}this.setNthWeekdayOfMonth(index,value);return}if(part==="second"||part==="minute"){if(index<0||index>=60){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}else if(part==="hour"){if(index<0||index>=24){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}else if(part==="day"){if(index<0||index>=31){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}else if(part==="month"){if(index<0||index>=12){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}this[part][index]=value};CronPattern.prototype.handleRangeWithStepping=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const matches=result[0].match(/^(\d+)-(\d+)\/(\d+)$/);if(matches===null)throw new TypeError("CronPattern: Syntax error, illegal range with stepping: '"+conf+"'");let[,lower,upper,steps]=matches;lower=parseInt(lower,10)+valueIndexOffset;upper=parseInt(upper,10)+valueIndexOffset;steps=parseInt(steps,10);if(isNaN(lower))throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");if(isNaN(upper))throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");if(isNaN(steps))throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");if(steps===0)throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");if(steps>this[type].length)throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part ("+this[type].length+")");if(lower>upper)throw new TypeError("CronPattern: From value is larger than to value: '"+conf+"'");for(let i=lower;i<=upper;i+=steps){this.setPart(type,i,result[1]||defaultValue)}};CronPattern.prototype.extractNth=function(conf,type){let rest=conf;let nth;if(rest.includes("#")){if(type!=="dayOfWeek"){throw new Error("CronPattern: nth (#) only allowed in day-of-week field")}nth=rest.split("#")[1];rest=rest.split("#")[0]}return[rest,nth]};CronPattern.prototype.handleRange=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const split=result[0].split("-");if(split.length!==2){throw new TypeError("CronPattern: Syntax error, illegal range: '"+conf+"'")}const lower=parseInt(split[0],10)+valueIndexOffset,upper=parseInt(split[1],10)+valueIndexOffset;if(isNaN(lower)){throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)")}else if(isNaN(upper)){throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)")}if(lower>upper){throw new TypeError("CronPattern: From value is larger than to value: '"+conf+"'")}for(let i=lower;i<=upper;i++){this.setPart(type,i,result[1]||defaultValue)}};CronPattern.prototype.handleStepping=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const split=result[0].split("/");if(split.length!==2){throw new TypeError("CronPattern: Syntax error, illegal stepping: '"+conf+"'")}let start=0;if(split[0]!=="*"){start=parseInt(split[0],10)+valueIndexOffset}const steps=parseInt(split[1],10);if(isNaN(steps))throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");if(steps===0)throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");if(steps>this[type].length)throw new TypeError("CronPattern: Syntax error, max steps for part is ("+this[type].length+")");for(let i=start;i<this[type].length;i+=steps){this.setPart(type,i,result[1]||defaultValue)}};CronPattern.prototype.replaceAlphaDays=function(conf){return conf.replace(/-sun/gi,"-7").replace(/sun/gi,"0").replace(/mon/gi,"1").replace(/tue/gi,"2").replace(/wed/gi,"3").replace(/thu/gi,"4").replace(/fri/gi,"5").replace(/sat/gi,"6")};CronPattern.prototype.replaceAlphaMonths=function(conf){return conf.replace(/jan/gi,"1").replace(/feb/gi,"2").replace(/mar/gi,"3").replace(/apr/gi,"4").replace(/may/gi,"5").replace(/jun/gi,"6").replace(/jul/gi,"7").replace(/aug/gi,"8").replace(/sep/gi,"9").replace(/oct/gi,"10").replace(/nov/gi,"11").replace(/dec/gi,"12")};CronPattern.prototype.handleNicknames=function(pattern){const cleanPattern=pattern.trim().toLowerCase();if(cleanPattern==="@yearly"||cleanPattern==="@annually"){return"0 0 1 1 *"}else if(cleanPattern==="@monthly"){return"0 0 1 * *"}else if(cleanPattern==="@weekly"){return"0 0 * * 0"}else if(cleanPattern==="@daily"){return"0 0 * * *"}else if(cleanPattern==="@hourly"){return"0 * * * *"}else{return pattern}};CronPattern.prototype.setNthWeekdayOfMonth=function(index,nthWeekday){if(nthWeekday==="L"){this["dayOfWeek"][index]=this["dayOfWeek"][index]|LAST_OCCURRENCE}else if(nthWeekday<6&&nthWeekday>0){this["dayOfWeek"][index]=this["dayOfWeek"][index]|OCCURRENCE_BITMASKS[nthWeekday-1]}else if(nthWeekday===ANY_OCCURRENCE){this["dayOfWeek"][index]=ANY_OCCURRENCE}else{throw new TypeError(`CronPattern: nth weekday of of range, should be 1-5 or L. Value: ${nthWeekday}`)}};const DaysOfMonth=[31,28,31,30,31,30,31,31,30,31,30,31];const RecursionSteps=[["month","year",0],["day","month",-1],["hour","day",0],["minute","hour",0],["second","minute",0]];function CronDate(d,tz){this.tz=tz;if(d&&d instanceof Date){if(!isNaN(d)){this.fromDate(d)}else{throw new TypeError("CronDate: Invalid date passed to CronDate constructor")}}else if(d===void 0){this.fromDate(new Date)}else if(d&&typeof d==="string"){this.fromString(d)}else if(d instanceof CronDate){this.fromCronDate(d)}else{throw new TypeError("CronDate: Invalid type ("+typeof d+") passed to CronDate constructor")}}CronDate.prototype.isNthWeekdayOfMonth=function(year,month,day,nth){const date=new Date(Date.UTC(year,month,day));const weekday=date.getUTCDay();let count=0;for(let d=1;d<=day;d++){if(new Date(Date.UTC(year,month,d)).getUTCDay()===weekday){count++}}if(nth&ANY_OCCURRENCE&&OCCURRENCE_BITMASKS[count-1]&nth){return true}if(nth&LAST_OCCURRENCE){const daysInMonth=new Date(Date.UTC(year,month+1,0)).getUTCDate();for(let d=day+1;d<=daysInMonth;d++){if(new Date(Date.UTC(year,month,d)).getUTCDay()===weekday){return false}}return true}return false};CronDate.prototype.fromDate=function(inDate){if(this.tz!==void 0){if(typeof this.tz==="number"){this.ms=inDate.getUTCMilliseconds();this.second=inDate.getUTCSeconds();this.minute=inDate.getUTCMinutes()+this.tz;this.hour=inDate.getUTCHours();this.day=inDate.getUTCDate();this.month=inDate.getUTCMonth();this.year=inDate.getUTCFullYear();this.apply()}else{const d=minitz.toTZ(inDate,this.tz);this.ms=inDate.getMilliseconds();this.second=d.s;this.minute=d.i;this.hour=d.h;this.day=d.d;this.month=d.m-1;this.year=d.y}}else{this.ms=inDate.getMilliseconds();this.second=inDate.getSeconds();this.minute=inDate.getMinutes();this.hour=inDate.getHours();this.day=inDate.getDate();this.month=inDate.getMonth();this.year=inDate.getFullYear()}};CronDate.prototype.fromCronDate=function(d){this.tz=d.tz;this.year=d.year;this.month=d.month;this.day=d.day;this.hour=d.hour;this.minute=d.minute;this.second=d.second;this.ms=d.ms};CronDate.prototype.apply=function(){if(this.month>11||this.day>DaysOfMonth[this.month]||this.hour>59||this.minute>59||this.second>59||this.hour<0||this.minute<0||this.second<0){const d=new Date(Date.UTC(this.year,this.month,this.day,this.hour,this.minute,this.second,this.ms));this.ms=d.getUTCMilliseconds();this.second=d.getUTCSeconds();this.minute=d.getUTCMinutes();this.hour=d.getUTCHours();this.day=d.getUTCDate();this.month=d.getUTCMonth();this.year=d.getUTCFullYear();return true}else{return false}};CronDate.prototype.fromString=function(str){if(typeof this.tz==="number"){const inDate=minitz.fromTZISO(str);this.ms=inDate.getUTCMilliseconds();this.second=inDate.getUTCSeconds();this.minute=inDate.getUTCMinutes();this.hour=inDate.getUTCHours();this.day=inDate.getUTCDate();this.month=inDate.getUTCMonth();this.year=inDate.getUTCFullYear();this.apply()}else{return this.fromDate(minitz.fromTZISO(str,this.tz))}};CronDate.prototype.findNext=function(options,target,pattern,offset){const originalTarget=this[target];let lastDayOfMonth;if(pattern.lastDayOfMonth){if(this.month!==1){lastDayOfMonth=DaysOfMonth[this.month]}else{lastDayOfMonth=new Date(Date.UTC(this.year,this.month+1,0,0,0,0,0)).getUTCDate()}}const fDomWeekDay=!pattern.starDOW&&target=="day"?new Date(Date.UTC(this.year,this.month,1,0,0,0,0)).getUTCDay():undefined;for(let i=this[target]+offset;i<pattern[target].length;i++){let match=pattern[target][i];if(target==="day"&&pattern.lastDayOfMonth&&i-offset==lastDayOfMonth){match=true}if(target==="day"&&!pattern.starDOW){let dowMatch=pattern.dayOfWeek[(fDomWeekDay+(i-offset-1))%7];if(dowMatch&&dowMatch&ANY_OCCURRENCE){dowMatch=this.isNthWeekdayOfMonth(this.year,this.month,i-offset,dowMatch)}else if(dowMatch){throw new Error(`CronDate: Invalid value for dayOfWeek encountered. ${dowMatch}`)}if(options.legacyMode&&!pattern.starDOM){match=match||dowMatch}else{match=match&&dowMatch}}if(match){this[target]=i-offset;return originalTarget!==this[target]?2:1}}return 3};CronDate.prototype.recurse=function(pattern,options,doing){const res=this.findNext(options,RecursionSteps[doing][0],pattern,RecursionSteps[doing][2]);if(res>1){let resetLevel=doing+1;while(resetLevel<RecursionSteps.length){this[RecursionSteps[resetLevel][0]]=-RecursionSteps[resetLevel][2];resetLevel++}if(res===3){this[RecursionSteps[doing][1]]++;this[RecursionSteps[doing][0]]=-RecursionSteps[doing][2];this.apply();return this.recurse(pattern,options,0)}else if(this.apply()){return this.recurse(pattern,options,doing-1)}}doing+=1;if(doing>=RecursionSteps.length){return this}else if(this.year>=3e3){return null}else{return this.recurse(pattern,options,doing)}};CronDate.prototype.increment=function(pattern,options,hasPreviousRun){this.second+=options.interval>1&&hasPreviousRun?options.interval:1;this.ms=0;this.apply();return this.recurse(pattern,options,0)};CronDate.prototype.getDate=function(internal){if(internal||this.tz===void 0){return new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.ms)}else{if(typeof this.tz==="number"){return new Date(Date.UTC(this.year,this.month,this.day,this.hour,this.minute-this.tz,this.second,this.ms))}else{return minitz(this.year,this.month+1,this.day,this.hour,this.minute,this.second,this.tz)}}};CronDate.prototype.getTime=function(){return this.getDate().getTime()};function isFunction(v){return Object.prototype.toString.call(v)==="[object Function]"||"function"===typeof v||v instanceof Function}function unrefTimer(timer){if(typeof Deno!=="undefined"&&typeof Deno.unrefTimer!=="undefined"){Deno.unrefTimer(timer)}else if(timer&&typeof timer.unref!=="undefined"){timer.unref()}}const maxDelay=30*1e3;const scheduledJobs=[];function Cron(pattern,fnOrOptions1,fnOrOptions2){if(!(this instanceof Cron)){return new Cron(pattern,fnOrOptions1,fnOrOptions2)}let options,func;if(isFunction(fnOrOptions1)){func=fnOrOptions1}else if(typeof fnOrOptions1==="object"){options=fnOrOptions1}else if(fnOrOptions1!==void 0){throw new Error("Cron: Invalid argument passed for optionsIn. Should be one of function, or object (options).")}if(isFunction(fnOrOptions2)){func=fnOrOptions2}else if(typeof fnOrOptions2==="object"){options=fnOrOptions2}else if(fnOrOptions2!==void 0){throw new Error("Cron: Invalid argument passed for funcIn. Should be one of function, or object (options).")}this.name=options?options.name:void 0;this.options=CronOptions(options);this._states={kill:false,blocking:false,previousRun:void 0,currentRun:void 0,once:void 0,currentTimeout:void 0,maxRuns:options?options.maxRuns:void 0,paused:options?options.paused:false,pattern:void 0};if(pattern&&(pattern instanceof Date||typeof pattern==="string"&&pattern.indexOf(":")>0)){this._states.once=new CronDate(pattern,this.options.timezone||this.options.utcOffset)}else{this._states.pattern=new CronPattern(pattern,this.options.timezone)}if(this.name){const existing=scheduledJobs.find(j=>j.name===this.name);if(existing){throw new Error("Cron: Tried to initialize new named job '"+this.name+"', but name already taken.")}else{scheduledJobs.push(this)}}if(func!==void 0){this.fn=func;this.schedule()}return this}Cron.prototype.nextRun=function(prev){const next=this._next(prev);return next?next.getDate():null};Cron.prototype.nextRuns=function(n,previous){if(n>this._states.maxRuns){n=this._states.maxRuns}const enumeration=[];let prev=previous||this._states.currentRun;while(n--&&(prev=this.nextRun(prev))){enumeration.push(prev)}return enumeration};Cron.prototype.getPattern=function(){return this._states.pattern?this._states.pattern.pattern:void 0};Cron.prototype.isRunning=function(){const nextRunTime=this.nextRun(this._states.currentRun);const isRunning=!this._states.paused;const isScheduled=this.fn!==void 0;const notIsKilled=!this._states.kill;return isRunning&&isScheduled&&notIsKilled&&nextRunTime!==null};Cron.prototype.isStopped=function(){return this._states.kill};Cron.prototype.isBusy=function(){return this._states.blocking};Cron.prototype.currentRun=function(){return this._states.currentRun?this._states.currentRun.getDate():null};Cron.prototype.previousRun=function(){return this._states.previousRun?this._states.previousRun.getDate():null};Cron.prototype.msToNext=function(prev){prev=prev||new Date;const next=this._next(prev);if(next){return next.getTime()-prev.getTime()}else{return null}};Cron.prototype.stop=function(){this._states.kill=true;if(this._states.currentTimeout){clearTimeout(this._states.currentTimeout)}const jobIndex=scheduledJobs.indexOf(this);if(jobIndex>=0){scheduledJobs.splice(jobIndex,1)}};Cron.prototype.pause=function(){this._states.paused=true;return!this._states.kill};Cron.prototype.resume=function(){this._states.paused=false;return!this._states.kill};Cron.prototype.schedule=function(func){if(func&&this.fn){throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.")}else if(func){this.fn=func}let waitMs=this.msToNext();const target=this.nextRun(this._states.currentRun);if(waitMs===null||waitMs===undefined||isNaN(waitMs)||target===null)return this;if(waitMs>maxDelay){waitMs=maxDelay}this._states.currentTimeout=setTimeout(()=>this._checkTrigger(target),waitMs);if(this._states.currentTimeout&&this.options.unref){unrefTimer(this._states.currentTimeout)}return this};Cron.prototype._trigger=async function(initiationDate){this._states.blocking=true;this._states.currentRun=new CronDate(void 0,this.options.timezone||this.options.utcOffset);if(this.options.catch){try{await this.fn(this,this.options.context)}catch(_e){if(isFunction(this.options.catch)){this.options.catch(_e,this)}}}else{await this.fn(this,this.options.context)}this._states.previousRun=new CronDate(initiationDate,this.options.timezone||this.options.utcOffset);this._states.blocking=false};Cron.prototype.trigger=async function(){await this._trigger()};Cron.prototype._checkTrigger=function(target){const now=new Date,shouldRun=!this._states.paused&&now.getTime()>=target,isBlocked=this._states.blocking&&this.options.protect;if(shouldRun&&!isBlocked){this._states.maxRuns--;this._trigger()}else{if(shouldRun&&isBlocked&&isFunction(this.options.protect)){setTimeout(()=>this.options.protect(this),0)}}this.schedule()};Cron.prototype._next=function(prev){const hasPreviousRun=prev||this._states.currentRun?true:false;prev=new CronDate(prev,this.options.timezone||this.options.utcOffset);if(this.options.startAt&&prev&&prev.getTime()<this.options.startAt.getTime()){prev=this.options.startAt}const nextRun=this._states.once||new CronDate(prev,this.options.timezone||this.options.utcOffset).increment(this._states.pattern,this.options,hasPreviousRun);if(this._states.once&&this._states.once.getTime()<=prev.getTime()){return null}else if(nextRun===null||this._states.maxRuns<=0||this._states.kill||this.options.stopAt&&nextRun.getTime()>=this.options.stopAt.getTime()){return null}else{return nextRun}};Cron.Cron=Cron;Cron.scheduledJobs=scheduledJobs;export{Cron,Cron as default,scheduledJobs};
\ No newline at end of file
diff --git a/node_modules/croner/.37fefdffffdfeebe-00000004.LICENSE b/.37fefdffffdfeebe-00000004.LICENSE
new file mode 100644
index 0000000000000000000000000000000000000000..931862dca1dbf5f4ca7f20721d35a966f886fedd
--- /dev/null
+++ b/.37fefdffffdfeebe-00000004.LICENSE
@@ -0,0 +1,22 @@
+The MIT License (MIT)
+
+Copyright (c) 2015-2021 Hexagon <github.com/Hexagon>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
diff --git a/node_modules/croner/.57feffdf7fbffd76-00000005.package.json b/.57feffdf7fbffd76-00000005.package.json
new file mode 100644
index 0000000000000000000000000000000000000000..88a89ff05e1ef8365da517508eb61c7ffaf6c2fc
--- /dev/null
+++ b/.57feffdf7fbffd76-00000005.package.json
@@ -0,0 +1,84 @@
+{
+  "name": "croner",
+  "version": "8.0.2",
+  "description": "Trigger functions and/or evaluate cron expressions in JavaScript. No dependencies. Most features. All environments.",
+  "author": "Hexagon <github.com/hexagon>",
+  "homepage": "https://hexagon.github.io/croner",
+  "contributors": [
+    {
+      "name": "Pehr Boman",
+      "email": "github.com/unkelpehr"
+    }
+  ],
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/hexagon/croner"
+  },
+  "bugs": {
+    "url": "https://github.com/hexagon/croner/issues"
+  },
+  "files": [
+    "dist/*.min.js",
+    "dist/*.min.cjs",
+    "types/*"
+  ],
+  "engines": {
+    "node": ">=18.0"
+  },
+  "keywords": [
+    "cron",
+    "front-end",
+    "backend",
+    "parser",
+    "croner",
+    "schedule",
+    "scheduler",
+    "timer",
+    "task",
+    "job",
+    "isomorphic",
+    "crontab"
+  ],
+  "scripts": {
+    "test": "uvu test test.croner.js",
+    "test:dist": "uvu test/node/js && npm run test:ts",
+    "test:bun": "bun test test/bun",
+    "test:lint": "eslint ./**/*.js ./**/*.cjs",
+    "test:lint:fix": "eslint --fix  ./**/*.js ./**/*.cjs",
+    "test:ts": "tsc --strict --noEmit ./test/node/ts/basics.ts",
+    "build": "npm update && npm run build:precleanup && npm run test:lint && npm run build:dist && npm run build:typings && npm run build:minify && npm run test:dist",
+    "build:ci": "npm run test:lint && npm run build:dist && npm run build:typings && npm run test:dist",
+    "build:precleanup": "(rm -rf types/* || del /Q types\\*) && (rm -rf dist/* || del /Q dist\\*)",
+    "build:dist": "rollup -c ./rollup.config.js",
+    "build:minify": "uglifyjs dist/croner.umd.js --source-map -o dist/croner.umd.min.js && uglifyjs dist/croner.js --source-map -o dist/croner.min.js && uglifyjs dist/croner.cjs --source-map -o dist/croner.min.cjs",
+    "build:typings": "tsc && tsc --build tsconfig.cjs.json"
+  },
+  "type": "module",
+  "main": "./dist/croner.min.cjs",
+  "browser": "./dist/croner.umd.min.js",
+  "module": "./dist/croner.min.js",
+  "types": "./types/croner.d.ts",
+  "exports": {
+    "./package.json": "./package.json",
+    ".": {
+      "import": {
+        "types": "./types/croner.d.ts",
+        "default": "./dist/croner.min.js"
+      },
+      "require": {
+        "types": "./types/croner.d.cts",
+        "default": "./dist/croner.min.cjs"
+      },
+      "browser": "./dist/croner.umd.js"
+    }
+  },
+  "devDependencies": {
+    "eslint": "^8.49.0",
+    "minitz": "^4.0.5",
+    "rollup": "^4.8.0",
+    "typescript": "^5.1.6",
+    "uglify-js": "^3.17.4",
+    "uvu": "^0.5.6"
+  },
+  "license": "MIT"
+}
diff --git a/node_modules/croner/.5fdadf4feebf5d9f-00000008.croner.d.ts b/.5fdadf4feebf5d9f-00000008.croner.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cd54e0f0f5ed21b284510b3bcc7836a5334a9406
--- /dev/null
+++ b/.5fdadf4feebf5d9f-00000008.croner.d.ts
@@ -0,0 +1,319 @@
+export type TimePoint = {
+    /**
+     * - 1970--
+     */
+    y: number;
+    /**
+     * - 1-12
+     */
+    m: number;
+    /**
+     * - 1-31
+     */
+    d: number;
+    /**
+     * - 0-24
+     */
+    h: number;
+    /**
+     * - 0-60 Minute
+     */
+    i: number;
+    /**
+     * - 0-60
+     */
+    s: number;
+    /**
+     * - Time zone in IANA database format 'Europe/Stockholm'
+     */
+    tz: string;
+};
+export type CatchCallbackFn = (e: unknown, job: Cron) => any;
+export type ProtectCallbackFn = (job: Cron) => any;
+/**
+ * - Cron scheduler options
+ */
+export type CronOptions = {
+    /**
+     * - Name of a job
+     */
+    name?: string;
+    /**
+     * - Job is paused
+     */
+    paused?: boolean;
+    /**
+     * - Job is about to be killed or killed
+     */
+    kill?: boolean;
+    /**
+     * - Continue exection even if a unhandled error is thrown by triggered function
+     * - If set to a function, execute function on catching the error.
+     */
+    catch?: boolean | CatchCallbackFn;
+    /**
+     * - Abort job instantly if nothing else keeps the event loop running.
+     */
+    unref?: boolean;
+    /**
+     * - Maximum nuber of executions
+     */
+    maxRuns?: number;
+    /**
+     * - Minimum interval between executions, in seconds
+     */
+    interval?: number;
+    /**
+     * - Skip current run if job is already running
+     */
+    protect?: boolean | ProtectCallbackFn;
+    /**
+     * - When to start running
+     */
+    startAt?: string | Date;
+    /**
+     * - When to stop running
+     */
+    stopAt?: string | Date;
+    /**
+     * - Time zone in Europe/Stockholm format
+     */
+    timezone?: string;
+    /**
+     * - Offset from UTC in minutes
+     */
+    utcOffset?: number;
+    /**
+     * - Combine day-of-month and day-of-week using true = OR, false = AND. Default is true = OR.
+     */
+    legacyMode?: boolean;
+    /**
+     * - Used to pass any object to scheduled function
+     */
+    context?: unknown;
+};
+/**
+ * Name for each part of the cron pattern
+ */
+export type CronPatternPart = ("second" | "minute" | "hour" | "day" | "month" | "dayOfWeek");
+/**
+ * Offset, 0 or -1.
+ *
+ * 0 offset is used for seconds,minutes and hours as they start on 1.
+ * -1 on days and months, as they start on 0
+ */
+export type CronIndexOffset = number;
+/**
+ * Cron entrypoint
+ *
+ * @constructor
+ * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string
+ * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern
+ * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern
+ * @returns {Cron}
+ */
+export function Cron(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function): Cron;
+export class Cron {
+    /**
+     * Cron entrypoint
+     *
+     * @constructor
+     * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string
+     * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern
+     * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern
+     * @returns {Cron}
+     */
+    constructor(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function);
+    /**
+     * @public
+     * @type {string|undefined} */
+    public name: string | undefined;
+    /**
+     * @public
+     * @type {CronOptions} */
+    public options: CronOptions;
+    /**
+     * Encapsulate all internal states in an object.
+     * Duplicate all options that can change to internal states, for example maxRuns and paused.
+     * @private
+     */
+    private _states;
+    fn: Function | CronOptions;
+    /**
+     * Find next runtime, based on supplied date. Strips milliseconds.
+     *
+     * @param {CronDate|Date|string} [prev] - Date to start from
+     * @returns {Date | null} - Next run time
+     */
+    nextRun(prev?: CronDate | Date | string): Date | null;
+    /**
+     * Find next n runs, based on supplied date. Strips milliseconds.
+     *
+     * @param {number} n - Number of runs to enumerate
+     * @param {Date|string} [previous] - Date to start from
+     * @returns {Date[]} - Next n run times
+     */
+    nextRuns(n: number, previous?: Date | string): Date[];
+    /**
+     * Return the original pattern, it there was one
+     *
+     * @returns {string|undefined} - Original pattern
+     */
+    getPattern(): string | undefined;
+    /**
+     * Indicates whether or not the cron job is scheduled and running, e.g. awaiting next trigger
+     * @public
+     *
+     * @returns {boolean} - Running or not
+     */
+    public isRunning(): boolean;
+    /**
+     * Indicates whether or not the cron job is permanently stopped
+     * @public
+     *
+     * @returns {boolean} - Running or not
+     */
+    public isStopped(): boolean;
+    /**
+     * Indicates whether or not the cron job is currently working
+     * @public
+     *
+     * @returns {boolean} - Running or not
+     */
+    public isBusy(): boolean;
+    /**
+     * Return current/previous run start time
+     * @public
+     *
+     * @returns {Date | null} - Previous run time
+     */
+    public currentRun(): Date | null;
+    /**
+     * Return previous run start time
+     * @public
+     *
+     * @returns {Date | null} - Previous run time
+     */
+    public previousRun(): Date | null;
+    /**
+     * Returns number of milliseconds to next run
+     * @public
+     *
+     * @param {CronDate|Date|string} [prev] - Starting date, defaults to now - minimum interval
+     * @returns {number | null}
+     */
+    public msToNext(prev?: CronDate | Date | string): number | null;
+    /**
+     * Stop execution
+     *
+     * Running this will forcefully stop the job, and prevent furter exection. `.resume()` will not work after stopping.
+     * It will also be removed from the scheduledJobs array if it were named.
+     *
+     * @public
+     */
+    public stop(): void;
+    /**
+     * Pause execution
+     * @public
+     *
+     * @returns {boolean} - Wether pause was successful
+     */
+    public pause(): boolean;
+    /**
+     * Resume execution
+     * @public
+     *
+     * @returns {boolean} - Wether resume was successful
+     */
+    public resume(): boolean;
+    /**
+     * Schedule a new job
+     * @public
+     *
+     * @param {Function} func - Function to be run each iteration of pattern
+     * @returns {Cron}
+     */
+    public schedule(func: Function): Cron;
+    private _trigger;
+    /**
+     * Trigger a run manually
+     * @public
+     */
+    public trigger(): Promise<void>;
+    private _checkTrigger;
+    private _next;
+}
+export namespace Cron {
+    export { Cron };
+    export { scheduledJobs };
+}
+/**
+ * An array containing all named cron jobs.
+ *
+ * @constant
+ * @type {Cron[]}
+ */
+export const scheduledJobs: Cron[];
+/**
+ * Converts date to CronDate
+ * @constructor
+ *
+ * @param {CronDate|Date|string} [d] - Input date, if using string representation ISO 8001 (2015-11-24T19:40:00) local timezone is expected
+ * @param {string|number} [tz] - String representation of target timezone in Europe/Stockholm format, or a number representing offset in minutes.
+*/
+declare function CronDate(d?: CronDate | Date | string, tz?: string | number): void;
+declare class CronDate {
+    /**
+     * Converts date to CronDate
+     * @constructor
+     *
+     * @param {CronDate|Date|string} [d] - Input date, if using string representation ISO 8001 (2015-11-24T19:40:00) local timezone is expected
+     * @param {string|number} [tz] - String representation of target timezone in Europe/Stockholm format, or a number representing offset in minutes.
+    */
+    constructor(d?: CronDate | Date | string, tz?: string | number);
+    /**
+     * TimeZone
+     * @type {string|number|undefined}
+     */
+    tz: string | number | undefined;
+    private isNthWeekdayOfMonth;
+    private fromDate;
+    ms: number;
+    second: number;
+    minute: number;
+    hour: number;
+    day: number;
+    month: number;
+    year: number;
+    private fromCronDate;
+    private apply;
+    private fromString;
+    private findNext;
+    private recurse;
+    /**
+     * Increment to next run time
+     * @public
+     *
+     * @param {string} pattern - The pattern used to increment current state
+     * @param {CronOptions} options - Cron options used for incrementing
+     * @param {boolean} [hasPreviousRun] - If this run should adhere to minimum interval
+     * @return {CronDate|null} - Returns itthis for chaining, or null if increment wasnt possible
+     */
+    public increment(pattern: string, options: CronOptions, hasPreviousRun?: boolean): CronDate | null;
+    /**
+     * Convert current state back to a javascript Date()
+     * @public
+     *
+     * @param {boolean} internal - If this is an internal call
+     * @returns {Date}
+     */
+    public getDate(internal: boolean): Date;
+    /**
+     * Convert current state back to a javascript Date() and return UTC milliseconds
+     * @public
+     *
+     * @returns {Date}
+     */
+    public getTime(): Date;
+}
+export { Cron as default };
diff --git a/node_modules/croner/.5ffffd6feffc7f3d-00000003.croner.umd.min.js b/.5ffffd6feffc7f3d-00000003.croner.umd.min.js
new file mode 100644
index 0000000000000000000000000000000000000000..6361817434fd95fd073747e7b8b6a5f81c62d43f
--- /dev/null
+++ b/.5ffffd6feffc7f3d-00000003.croner.umd.min.js
@@ -0,0 +1 @@
+(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,global.Cron=factory())})(this,function(){"use strict";function minitz(y,m,d,h,i,s,tz,throwOnInvalid){return minitz.fromTZ(minitz.tp(y,m,d,h,i,s,tz),throwOnInvalid)}minitz.fromTZISO=(localTimeStr,tz,throwOnInvalid)=>{return minitz.fromTZ(parseISOLocal(localTimeStr,tz),throwOnInvalid)};minitz.fromTZ=function(tp,throwOnInvalid){const inDate=new Date(Date.UTC(tp.y,tp.m-1,tp.d,tp.h,tp.i,tp.s)),offset=getTimezoneOffset(tp.tz,inDate),dateGuess=new Date(inDate.getTime()-offset),dateOffsGuess=getTimezoneOffset(tp.tz,dateGuess);if(dateOffsGuess-offset===0){return dateGuess}else{const dateGuess2=new Date(inDate.getTime()-dateOffsGuess),dateOffsGuess2=getTimezoneOffset(tp.tz,dateGuess2);if(dateOffsGuess2-dateOffsGuess===0){return dateGuess2}else if(!throwOnInvalid&&dateOffsGuess2-dateOffsGuess>0){return dateGuess2}else if(!throwOnInvalid){return dateGuess}else{throw new Error("Invalid date passed to fromTZ()")}}};minitz.toTZ=function(d,tzStr){const localDateString=d.toLocaleString("en-US",{timeZone:tzStr}).replace(/[\u202f]/," ");const td=new Date(localDateString);return{y:td.getFullYear(),m:td.getMonth()+1,d:td.getDate(),h:td.getHours(),i:td.getMinutes(),s:td.getSeconds(),tz:tzStr}};minitz.tp=(y,m,d,h,i,s,tz)=>{return{y:y,m:m,d:d,h:h,i:i,s:s,tz:tz}};function getTimezoneOffset(timeZone,date=new Date){const tz=date.toLocaleString("en-US",{timeZone:timeZone,timeZoneName:"shortOffset"}).split(" ").slice(-1)[0];const dateString=date.toLocaleString("en-US").replace(/[\u202f]/," ");return Date.parse(`${dateString} GMT`)-Date.parse(`${dateString} ${tz}`)}function parseISOLocal(dtStr,tz){const pd=new Date(Date.parse(dtStr));if(isNaN(pd)){throw new Error("minitz: Invalid ISO8601 passed to parser.")}const stringEnd=dtStr.substring(9);if(dtStr.includes("Z")||stringEnd.includes("-")||stringEnd.includes("+")){return minitz.tp(pd.getUTCFullYear(),pd.getUTCMonth()+1,pd.getUTCDate(),pd.getUTCHours(),pd.getUTCMinutes(),pd.getUTCSeconds(),"Etc/UTC")}else{return minitz.tp(pd.getFullYear(),pd.getMonth()+1,pd.getDate(),pd.getHours(),pd.getMinutes(),pd.getSeconds(),tz)}}minitz.minitz=minitz;function CronOptions(options){if(options===void 0){options={}}delete options.name;options.legacyMode=options.legacyMode===void 0?true:options.legacyMode;options.paused=options.paused===void 0?false:options.paused;options.maxRuns=options.maxRuns===void 0?Infinity:options.maxRuns;options.catch=options.catch===void 0?false:options.catch;options.interval=options.interval===void 0?0:parseInt(options.interval,10);options.utcOffset=options.utcOffset===void 0?void 0:parseInt(options.utcOffset,10);options.unref=options.unref===void 0?false:options.unref;if(options.startAt){options.startAt=new CronDate(options.startAt,options.timezone)}if(options.stopAt){options.stopAt=new CronDate(options.stopAt,options.timezone)}if(options.interval!==null){if(isNaN(options.interval)){throw new Error("CronOptions: Supplied value for interval is not a number")}else if(options.interval<0){throw new Error("CronOptions: Supplied value for interval can not be negative")}}if(options.utcOffset!==void 0){if(isNaN(options.utcOffset)){throw new Error("CronOptions: Invalid value passed for utcOffset, should be number representing minutes offset from UTC.")}else if(options.utcOffset<-870||options.utcOffset>870){throw new Error("CronOptions: utcOffset out of bounds.")}if(options.utcOffset!==void 0&&options.timezone){throw new Error("CronOptions: Combining 'utcOffset' with 'timezone' is not allowed.")}}if(options.unref!==true&&options.unref!==false){throw new Error("CronOptions: Unref should be either true, false or undefined(false).")}return options}const LAST_OCCURRENCE=32;const ANY_OCCURRENCE=1|2|4|8|16|LAST_OCCURRENCE;const OCCURRENCE_BITMASKS=[1,2,4,16,16];function CronPattern(pattern,timezone){this.pattern=pattern;this.timezone=timezone;this.second=Array(60).fill(0);this.minute=Array(60).fill(0);this.hour=Array(24).fill(0);this.day=Array(31).fill(0);this.month=Array(12).fill(0);this.dayOfWeek=Array(7).fill(0);this.lastDayOfMonth=false;this.starDOM=false;this.starDOW=false;this.parse()}CronPattern.prototype.parse=function(){if(!(typeof this.pattern==="string"||this.pattern.constructor===String)){throw new TypeError("CronPattern: Pattern has to be of type string.")}if(this.pattern.indexOf("@")>=0)this.pattern=this.handleNicknames(this.pattern).trim();const parts=this.pattern.replace(/\s+/g," ").split(" ");if(parts.length<5||parts.length>6){throw new TypeError("CronPattern: invalid configuration format ('"+this.pattern+"'), exactly five or six space separated parts are required.")}if(parts.length===5){parts.unshift("0")}if(parts[3].indexOf("L")>=0){parts[3]=parts[3].replace("L","");this.lastDayOfMonth=true}if(parts[3]=="*"){this.starDOM=true}if(parts[4].length>=3)parts[4]=this.replaceAlphaMonths(parts[4]);if(parts[5].length>=3)parts[5]=this.replaceAlphaDays(parts[5]);if(parts[5]=="*"){this.starDOW=true}if(this.pattern.indexOf("?")>=0){const initDate=new CronDate(new Date,this.timezone).getDate(true);parts[0]=parts[0].replace("?",initDate.getSeconds());parts[1]=parts[1].replace("?",initDate.getMinutes());parts[2]=parts[2].replace("?",initDate.getHours());if(!this.starDOM)parts[3]=parts[3].replace("?",initDate.getDate());parts[4]=parts[4].replace("?",initDate.getMonth()+1);if(!this.starDOW)parts[5]=parts[5].replace("?",initDate.getDay())}this.throwAtIllegalCharacters(parts);this.partToArray("second",parts[0],0,1);this.partToArray("minute",parts[1],0,1);this.partToArray("hour",parts[2],0,1);this.partToArray("day",parts[3],-1,1);this.partToArray("month",parts[4],-1,1);this.partToArray("dayOfWeek",parts[5],0,ANY_OCCURRENCE);if(this.dayOfWeek[7]){this.dayOfWeek[0]=this.dayOfWeek[7]}};CronPattern.prototype.partToArray=function(type,conf,valueIndexOffset,defaultValue){const arr=this[type];const lastDayOfMonth=type==="day"&&this.lastDayOfMonth;if(conf===""&&!lastDayOfMonth)throw new TypeError("CronPattern: configuration entry "+type+" ("+conf+") is empty, check for trailing spaces.");if(conf==="*")return arr.fill(defaultValue);const split=conf.split(",");if(split.length>1){for(let i=0;i<split.length;i++){this.partToArray(type,split[i],valueIndexOffset,defaultValue)}}else if(conf.indexOf("-")!==-1&&conf.indexOf("/")!==-1){this.handleRangeWithStepping(conf,type,valueIndexOffset,defaultValue)}else if(conf.indexOf("-")!==-1){this.handleRange(conf,type,valueIndexOffset,defaultValue)}else if(conf.indexOf("/")!==-1){this.handleStepping(conf,type,valueIndexOffset,defaultValue)}else if(conf!==""){this.handleNumber(conf,type,valueIndexOffset,defaultValue)}};CronPattern.prototype.throwAtIllegalCharacters=function(parts){for(let i=0;i<parts.length;i++){const reValidCron=i===5?/[^/*0-9,\-#L]+/:/[^/*0-9,-]+/;if(reValidCron.test(parts[i])){throw new TypeError("CronPattern: configuration entry "+i+" ("+parts[i]+") contains illegal characters.")}}};CronPattern.prototype.handleNumber=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const i=parseInt(result[0],10)+valueIndexOffset;if(isNaN(i)){throw new TypeError("CronPattern: "+type+" is not a number: '"+conf+"'")}this.setPart(type,i,result[1]||defaultValue)};CronPattern.prototype.setPart=function(part,index,value){if(!Object.prototype.hasOwnProperty.call(this,part)){throw new TypeError("CronPattern: Invalid part specified: "+part)}if(part==="dayOfWeek"){if(index===7)index=0;if((index<0||index>6)&&index!=="L"){throw new RangeError("CronPattern: Invalid value for dayOfWeek: "+index)}this.setNthWeekdayOfMonth(index,value);return}if(part==="second"||part==="minute"){if(index<0||index>=60){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}else if(part==="hour"){if(index<0||index>=24){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}else if(part==="day"){if(index<0||index>=31){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}else if(part==="month"){if(index<0||index>=12){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}this[part][index]=value};CronPattern.prototype.handleRangeWithStepping=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const matches=result[0].match(/^(\d+)-(\d+)\/(\d+)$/);if(matches===null)throw new TypeError("CronPattern: Syntax error, illegal range with stepping: '"+conf+"'");let[,lower,upper,steps]=matches;lower=parseInt(lower,10)+valueIndexOffset;upper=parseInt(upper,10)+valueIndexOffset;steps=parseInt(steps,10);if(isNaN(lower))throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");if(isNaN(upper))throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");if(isNaN(steps))throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");if(steps===0)throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");if(steps>this[type].length)throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part ("+this[type].length+")");if(lower>upper)throw new TypeError("CronPattern: From value is larger than to value: '"+conf+"'");for(let i=lower;i<=upper;i+=steps){this.setPart(type,i,result[1]||defaultValue)}};CronPattern.prototype.extractNth=function(conf,type){let rest=conf;let nth;if(rest.includes("#")){if(type!=="dayOfWeek"){throw new Error("CronPattern: nth (#) only allowed in day-of-week field")}nth=rest.split("#")[1];rest=rest.split("#")[0]}return[rest,nth]};CronPattern.prototype.handleRange=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const split=result[0].split("-");if(split.length!==2){throw new TypeError("CronPattern: Syntax error, illegal range: '"+conf+"'")}const lower=parseInt(split[0],10)+valueIndexOffset,upper=parseInt(split[1],10)+valueIndexOffset;if(isNaN(lower)){throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)")}else if(isNaN(upper)){throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)")}if(lower>upper){throw new TypeError("CronPattern: From value is larger than to value: '"+conf+"'")}for(let i=lower;i<=upper;i++){this.setPart(type,i,result[1]||defaultValue)}};CronPattern.prototype.handleStepping=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const split=result[0].split("/");if(split.length!==2){throw new TypeError("CronPattern: Syntax error, illegal stepping: '"+conf+"'")}let start=0;if(split[0]!=="*"){start=parseInt(split[0],10)+valueIndexOffset}const steps=parseInt(split[1],10);if(isNaN(steps))throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");if(steps===0)throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");if(steps>this[type].length)throw new TypeError("CronPattern: Syntax error, max steps for part is ("+this[type].length+")");for(let i=start;i<this[type].length;i+=steps){this.setPart(type,i,result[1]||defaultValue)}};CronPattern.prototype.replaceAlphaDays=function(conf){return conf.replace(/-sun/gi,"-7").replace(/sun/gi,"0").replace(/mon/gi,"1").replace(/tue/gi,"2").replace(/wed/gi,"3").replace(/thu/gi,"4").replace(/fri/gi,"5").replace(/sat/gi,"6")};CronPattern.prototype.replaceAlphaMonths=function(conf){return conf.replace(/jan/gi,"1").replace(/feb/gi,"2").replace(/mar/gi,"3").replace(/apr/gi,"4").replace(/may/gi,"5").replace(/jun/gi,"6").replace(/jul/gi,"7").replace(/aug/gi,"8").replace(/sep/gi,"9").replace(/oct/gi,"10").replace(/nov/gi,"11").replace(/dec/gi,"12")};CronPattern.prototype.handleNicknames=function(pattern){const cleanPattern=pattern.trim().toLowerCase();if(cleanPattern==="@yearly"||cleanPattern==="@annually"){return"0 0 1 1 *"}else if(cleanPattern==="@monthly"){return"0 0 1 * *"}else if(cleanPattern==="@weekly"){return"0 0 * * 0"}else if(cleanPattern==="@daily"){return"0 0 * * *"}else if(cleanPattern==="@hourly"){return"0 * * * *"}else{return pattern}};CronPattern.prototype.setNthWeekdayOfMonth=function(index,nthWeekday){if(nthWeekday==="L"){this["dayOfWeek"][index]=this["dayOfWeek"][index]|LAST_OCCURRENCE}else if(nthWeekday<6&&nthWeekday>0){this["dayOfWeek"][index]=this["dayOfWeek"][index]|OCCURRENCE_BITMASKS[nthWeekday-1]}else if(nthWeekday===ANY_OCCURRENCE){this["dayOfWeek"][index]=ANY_OCCURRENCE}else{throw new TypeError(`CronPattern: nth weekday of of range, should be 1-5 or L. Value: ${nthWeekday}`)}};const DaysOfMonth=[31,28,31,30,31,30,31,31,30,31,30,31];const RecursionSteps=[["month","year",0],["day","month",-1],["hour","day",0],["minute","hour",0],["second","minute",0]];function CronDate(d,tz){this.tz=tz;if(d&&d instanceof Date){if(!isNaN(d)){this.fromDate(d)}else{throw new TypeError("CronDate: Invalid date passed to CronDate constructor")}}else if(d===void 0){this.fromDate(new Date)}else if(d&&typeof d==="string"){this.fromString(d)}else if(d instanceof CronDate){this.fromCronDate(d)}else{throw new TypeError("CronDate: Invalid type ("+typeof d+") passed to CronDate constructor")}}CronDate.prototype.isNthWeekdayOfMonth=function(year,month,day,nth){const date=new Date(Date.UTC(year,month,day));const weekday=date.getUTCDay();let count=0;for(let d=1;d<=day;d++){if(new Date(Date.UTC(year,month,d)).getUTCDay()===weekday){count++}}if(nth&ANY_OCCURRENCE&&OCCURRENCE_BITMASKS[count-1]&nth){return true}if(nth&LAST_OCCURRENCE){const daysInMonth=new Date(Date.UTC(year,month+1,0)).getUTCDate();for(let d=day+1;d<=daysInMonth;d++){if(new Date(Date.UTC(year,month,d)).getUTCDay()===weekday){return false}}return true}return false};CronDate.prototype.fromDate=function(inDate){if(this.tz!==void 0){if(typeof this.tz==="number"){this.ms=inDate.getUTCMilliseconds();this.second=inDate.getUTCSeconds();this.minute=inDate.getUTCMinutes()+this.tz;this.hour=inDate.getUTCHours();this.day=inDate.getUTCDate();this.month=inDate.getUTCMonth();this.year=inDate.getUTCFullYear();this.apply()}else{const d=minitz.toTZ(inDate,this.tz);this.ms=inDate.getMilliseconds();this.second=d.s;this.minute=d.i;this.hour=d.h;this.day=d.d;this.month=d.m-1;this.year=d.y}}else{this.ms=inDate.getMilliseconds();this.second=inDate.getSeconds();this.minute=inDate.getMinutes();this.hour=inDate.getHours();this.day=inDate.getDate();this.month=inDate.getMonth();this.year=inDate.getFullYear()}};CronDate.prototype.fromCronDate=function(d){this.tz=d.tz;this.year=d.year;this.month=d.month;this.day=d.day;this.hour=d.hour;this.minute=d.minute;this.second=d.second;this.ms=d.ms};CronDate.prototype.apply=function(){if(this.month>11||this.day>DaysOfMonth[this.month]||this.hour>59||this.minute>59||this.second>59||this.hour<0||this.minute<0||this.second<0){const d=new Date(Date.UTC(this.year,this.month,this.day,this.hour,this.minute,this.second,this.ms));this.ms=d.getUTCMilliseconds();this.second=d.getUTCSeconds();this.minute=d.getUTCMinutes();this.hour=d.getUTCHours();this.day=d.getUTCDate();this.month=d.getUTCMonth();this.year=d.getUTCFullYear();return true}else{return false}};CronDate.prototype.fromString=function(str){if(typeof this.tz==="number"){const inDate=minitz.fromTZISO(str);this.ms=inDate.getUTCMilliseconds();this.second=inDate.getUTCSeconds();this.minute=inDate.getUTCMinutes();this.hour=inDate.getUTCHours();this.day=inDate.getUTCDate();this.month=inDate.getUTCMonth();this.year=inDate.getUTCFullYear();this.apply()}else{return this.fromDate(minitz.fromTZISO(str,this.tz))}};CronDate.prototype.findNext=function(options,target,pattern,offset){const originalTarget=this[target];let lastDayOfMonth;if(pattern.lastDayOfMonth){if(this.month!==1){lastDayOfMonth=DaysOfMonth[this.month]}else{lastDayOfMonth=new Date(Date.UTC(this.year,this.month+1,0,0,0,0,0)).getUTCDate()}}const fDomWeekDay=!pattern.starDOW&&target=="day"?new Date(Date.UTC(this.year,this.month,1,0,0,0,0)).getUTCDay():undefined;for(let i=this[target]+offset;i<pattern[target].length;i++){let match=pattern[target][i];if(target==="day"&&pattern.lastDayOfMonth&&i-offset==lastDayOfMonth){match=true}if(target==="day"&&!pattern.starDOW){let dowMatch=pattern.dayOfWeek[(fDomWeekDay+(i-offset-1))%7];if(dowMatch&&dowMatch&ANY_OCCURRENCE){dowMatch=this.isNthWeekdayOfMonth(this.year,this.month,i-offset,dowMatch)}else if(dowMatch){throw new Error(`CronDate: Invalid value for dayOfWeek encountered. ${dowMatch}`)}if(options.legacyMode&&!pattern.starDOM){match=match||dowMatch}else{match=match&&dowMatch}}if(match){this[target]=i-offset;return originalTarget!==this[target]?2:1}}return 3};CronDate.prototype.recurse=function(pattern,options,doing){const res=this.findNext(options,RecursionSteps[doing][0],pattern,RecursionSteps[doing][2]);if(res>1){let resetLevel=doing+1;while(resetLevel<RecursionSteps.length){this[RecursionSteps[resetLevel][0]]=-RecursionSteps[resetLevel][2];resetLevel++}if(res===3){this[RecursionSteps[doing][1]]++;this[RecursionSteps[doing][0]]=-RecursionSteps[doing][2];this.apply();return this.recurse(pattern,options,0)}else if(this.apply()){return this.recurse(pattern,options,doing-1)}}doing+=1;if(doing>=RecursionSteps.length){return this}else if(this.year>=3e3){return null}else{return this.recurse(pattern,options,doing)}};CronDate.prototype.increment=function(pattern,options,hasPreviousRun){this.second+=options.interval>1&&hasPreviousRun?options.interval:1;this.ms=0;this.apply();return this.recurse(pattern,options,0)};CronDate.prototype.getDate=function(internal){if(internal||this.tz===void 0){return new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.ms)}else{if(typeof this.tz==="number"){return new Date(Date.UTC(this.year,this.month,this.day,this.hour,this.minute-this.tz,this.second,this.ms))}else{return minitz(this.year,this.month+1,this.day,this.hour,this.minute,this.second,this.tz)}}};CronDate.prototype.getTime=function(){return this.getDate().getTime()};function isFunction(v){return Object.prototype.toString.call(v)==="[object Function]"||"function"===typeof v||v instanceof Function}function unrefTimer(timer){if(typeof Deno!=="undefined"&&typeof Deno.unrefTimer!=="undefined"){Deno.unrefTimer(timer)}else if(timer&&typeof timer.unref!=="undefined"){timer.unref()}}const maxDelay=30*1e3;const scheduledJobs=[];function Cron(pattern,fnOrOptions1,fnOrOptions2){if(!(this instanceof Cron)){return new Cron(pattern,fnOrOptions1,fnOrOptions2)}let options,func;if(isFunction(fnOrOptions1)){func=fnOrOptions1}else if(typeof fnOrOptions1==="object"){options=fnOrOptions1}else if(fnOrOptions1!==void 0){throw new Error("Cron: Invalid argument passed for optionsIn. Should be one of function, or object (options).")}if(isFunction(fnOrOptions2)){func=fnOrOptions2}else if(typeof fnOrOptions2==="object"){options=fnOrOptions2}else if(fnOrOptions2!==void 0){throw new Error("Cron: Invalid argument passed for funcIn. Should be one of function, or object (options).")}this.name=options?options.name:void 0;this.options=CronOptions(options);this._states={kill:false,blocking:false,previousRun:void 0,currentRun:void 0,once:void 0,currentTimeout:void 0,maxRuns:options?options.maxRuns:void 0,paused:options?options.paused:false,pattern:void 0};if(pattern&&(pattern instanceof Date||typeof pattern==="string"&&pattern.indexOf(":")>0)){this._states.once=new CronDate(pattern,this.options.timezone||this.options.utcOffset)}else{this._states.pattern=new CronPattern(pattern,this.options.timezone)}if(this.name){const existing=scheduledJobs.find(j=>j.name===this.name);if(existing){throw new Error("Cron: Tried to initialize new named job '"+this.name+"', but name already taken.")}else{scheduledJobs.push(this)}}if(func!==void 0){this.fn=func;this.schedule()}return this}Cron.prototype.nextRun=function(prev){const next=this._next(prev);return next?next.getDate():null};Cron.prototype.nextRuns=function(n,previous){if(n>this._states.maxRuns){n=this._states.maxRuns}const enumeration=[];let prev=previous||this._states.currentRun;while(n--&&(prev=this.nextRun(prev))){enumeration.push(prev)}return enumeration};Cron.prototype.getPattern=function(){return this._states.pattern?this._states.pattern.pattern:void 0};Cron.prototype.isRunning=function(){const nextRunTime=this.nextRun(this._states.currentRun);const isRunning=!this._states.paused;const isScheduled=this.fn!==void 0;const notIsKilled=!this._states.kill;return isRunning&&isScheduled&&notIsKilled&&nextRunTime!==null};Cron.prototype.isStopped=function(){return this._states.kill};Cron.prototype.isBusy=function(){return this._states.blocking};Cron.prototype.currentRun=function(){return this._states.currentRun?this._states.currentRun.getDate():null};Cron.prototype.previousRun=function(){return this._states.previousRun?this._states.previousRun.getDate():null};Cron.prototype.msToNext=function(prev){prev=prev||new Date;const next=this._next(prev);if(next){return next.getTime()-prev.getTime()}else{return null}};Cron.prototype.stop=function(){this._states.kill=true;if(this._states.currentTimeout){clearTimeout(this._states.currentTimeout)}const jobIndex=scheduledJobs.indexOf(this);if(jobIndex>=0){scheduledJobs.splice(jobIndex,1)}};Cron.prototype.pause=function(){this._states.paused=true;return!this._states.kill};Cron.prototype.resume=function(){this._states.paused=false;return!this._states.kill};Cron.prototype.schedule=function(func){if(func&&this.fn){throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.")}else if(func){this.fn=func}let waitMs=this.msToNext();const target=this.nextRun(this._states.currentRun);if(waitMs===null||waitMs===undefined||isNaN(waitMs)||target===null)return this;if(waitMs>maxDelay){waitMs=maxDelay}this._states.currentTimeout=setTimeout(()=>this._checkTrigger(target),waitMs);if(this._states.currentTimeout&&this.options.unref){unrefTimer(this._states.currentTimeout)}return this};Cron.prototype._trigger=async function(initiationDate){this._states.blocking=true;this._states.currentRun=new CronDate(void 0,this.options.timezone||this.options.utcOffset);if(this.options.catch){try{await this.fn(this,this.options.context)}catch(_e){if(isFunction(this.options.catch)){this.options.catch(_e,this)}}}else{await this.fn(this,this.options.context)}this._states.previousRun=new CronDate(initiationDate,this.options.timezone||this.options.utcOffset);this._states.blocking=false};Cron.prototype.trigger=async function(){await this._trigger()};Cron.prototype._checkTrigger=function(target){const now=new Date,shouldRun=!this._states.paused&&now.getTime()>=target,isBlocked=this._states.blocking&&this.options.protect;if(shouldRun&&!isBlocked){this._states.maxRuns--;this._trigger()}else{if(shouldRun&&isBlocked&&isFunction(this.options.protect)){setTimeout(()=>this.options.protect(this),0)}}this.schedule()};Cron.prototype._next=function(prev){const hasPreviousRun=prev||this._states.currentRun?true:false;prev=new CronDate(prev,this.options.timezone||this.options.utcOffset);if(this.options.startAt&&prev&&prev.getTime()<this.options.startAt.getTime()){prev=this.options.startAt}const nextRun=this._states.once||new CronDate(prev,this.options.timezone||this.options.utcOffset).increment(this._states.pattern,this.options,hasPreviousRun);if(this._states.once&&this._states.once.getTime()<=prev.getTime()){return null}else if(nextRun===null||this._states.maxRuns<=0||this._states.kill||this.options.stopAt&&nextRun.getTime()>=this.options.stopAt.getTime()){return null}else{return nextRun}};Cron.Cron=Cron;Cron.scheduledJobs=scheduledJobs;return Cron});
\ No newline at end of file
diff --git a/node_modules/croner/.7fffdf5f3d8dbff4-00000007.croner.d.cts b/.7fffdf5f3d8dbff4-00000007.croner.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..9eb643276128e99d17b81149c04ea9798828139a
--- /dev/null
+++ b/.7fffdf5f3d8dbff4-00000007.croner.d.cts
@@ -0,0 +1,318 @@
+export = Cron;
+/**
+ * Cron entrypoint
+ *
+ * @constructor
+ * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string
+ * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern
+ * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern
+ * @returns {Cron}
+ */
+declare function Cron(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function): Cron;
+declare class Cron {
+    /**
+     * Cron entrypoint
+     *
+     * @constructor
+     * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string
+     * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern
+     * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern
+     * @returns {Cron}
+     */
+    constructor(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function);
+    /**
+     * @public
+     * @type {string|undefined} */
+    public name: string | undefined;
+    /**
+     * @public
+     * @type {CronOptions} */
+    public options: CronOptions;
+    /**
+     * Encapsulate all internal states in an object.
+     * Duplicate all options that can change to internal states, for example maxRuns and paused.
+     * @private
+     */
+    private _states;
+    fn: Function | CronOptions;
+    /**
+     * Find next runtime, based on supplied date. Strips milliseconds.
+     *
+     * @param {CronDate|Date|string} [prev] - Date to start from
+     * @returns {Date | null} - Next run time
+     */
+    nextRun(prev?: CronDate | Date | string): Date | null;
+    /**
+     * Find next n runs, based on supplied date. Strips milliseconds.
+     *
+     * @param {number} n - Number of runs to enumerate
+     * @param {Date|string} [previous] - Date to start from
+     * @returns {Date[]} - Next n run times
+     */
+    nextRuns(n: number, previous?: Date | string): Date[];
+    /**
+     * Return the original pattern, it there was one
+     *
+     * @returns {string|undefined} - Original pattern
+     */
+    getPattern(): string | undefined;
+    /**
+     * Indicates whether or not the cron job is scheduled and running, e.g. awaiting next trigger
+     * @public
+     *
+     * @returns {boolean} - Running or not
+     */
+    public isRunning(): boolean;
+    /**
+     * Indicates whether or not the cron job is permanently stopped
+     * @public
+     *
+     * @returns {boolean} - Running or not
+     */
+    public isStopped(): boolean;
+    /**
+     * Indicates whether or not the cron job is currently working
+     * @public
+     *
+     * @returns {boolean} - Running or not
+     */
+    public isBusy(): boolean;
+    /**
+     * Return current/previous run start time
+     * @public
+     *
+     * @returns {Date | null} - Previous run time
+     */
+    public currentRun(): Date | null;
+    /**
+     * Return previous run start time
+     * @public
+     *
+     * @returns {Date | null} - Previous run time
+     */
+    public previousRun(): Date | null;
+    /**
+     * Returns number of milliseconds to next run
+     * @public
+     *
+     * @param {CronDate|Date|string} [prev] - Starting date, defaults to now - minimum interval
+     * @returns {number | null}
+     */
+    public msToNext(prev?: CronDate | Date | string): number | null;
+    /**
+     * Stop execution
+     *
+     * Running this will forcefully stop the job, and prevent furter exection. `.resume()` will not work after stopping.
+     * It will also be removed from the scheduledJobs array if it were named.
+     *
+     * @public
+     */
+    public stop(): void;
+    /**
+     * Pause execution
+     * @public
+     *
+     * @returns {boolean} - Wether pause was successful
+     */
+    public pause(): boolean;
+    /**
+     * Resume execution
+     * @public
+     *
+     * @returns {boolean} - Wether resume was successful
+     */
+    public resume(): boolean;
+    /**
+     * Schedule a new job
+     * @public
+     *
+     * @param {Function} func - Function to be run each iteration of pattern
+     * @returns {Cron}
+     */
+    public schedule(func: Function): Cron;
+    private _trigger;
+    /**
+     * Trigger a run manually
+     * @public
+     */
+    public trigger(): Promise<void>;
+    private _checkTrigger;
+    private _next;
+}
+declare namespace Cron {
+    export { Cron, scheduledJobs, TimePoint, CatchCallbackFn, ProtectCallbackFn, CronOptions, CronPatternPart, CronIndexOffset };
+}
+/**
+ * - Cron scheduler options
+ */
+type CronOptions = {
+    /**
+     * - Name of a job
+     */
+    name?: string;
+    /**
+     * - Job is paused
+     */
+    paused?: boolean;
+    /**
+     * - Job is about to be killed or killed
+     */
+    kill?: boolean;
+    /**
+     * - Continue exection even if a unhandled error is thrown by triggered function
+     * - If set to a function, execute function on catching the error.
+     */
+    catch?: boolean | CatchCallbackFn;
+    /**
+     * - Abort job instantly if nothing else keeps the event loop running.
+     */
+    unref?: boolean;
+    /**
+     * - Maximum nuber of executions
+     */
+    maxRuns?: number;
+    /**
+     * - Minimum interval between executions, in seconds
+     */
+    interval?: number;
+    /**
+     * - Skip current run if job is already running
+     */
+    protect?: boolean | ProtectCallbackFn;
+    /**
+     * - When to start running
+     */
+    startAt?: string | Date;
+    /**
+     * - When to stop running
+     */
+    stopAt?: string | Date;
+    /**
+     * - Time zone in Europe/Stockholm format
+     */
+    timezone?: string;
+    /**
+     * - Offset from UTC in minutes
+     */
+    utcOffset?: number;
+    /**
+     * - Combine day-of-month and day-of-week using true = OR, false = AND. Default is true = OR.
+     */
+    legacyMode?: boolean;
+    /**
+     * - Used to pass any object to scheduled function
+     */
+    context?: unknown;
+};
+/**
+ * Converts date to CronDate
+ * @constructor
+ *
+ * @param {CronDate|Date|string} [d] - Input date, if using string representation ISO 8001 (2015-11-24T19:40:00) local timezone is expected
+ * @param {string|number} [tz] - String representation of target timezone in Europe/Stockholm format, or a number representing offset in minutes.
+*/
+declare function CronDate(d?: CronDate | Date | string, tz?: string | number): void;
+declare class CronDate {
+    /**
+     * Converts date to CronDate
+     * @constructor
+     *
+     * @param {CronDate|Date|string} [d] - Input date, if using string representation ISO 8001 (2015-11-24T19:40:00) local timezone is expected
+     * @param {string|number} [tz] - String representation of target timezone in Europe/Stockholm format, or a number representing offset in minutes.
+    */
+    constructor(d?: CronDate | Date | string, tz?: string | number);
+    /**
+     * TimeZone
+     * @type {string|number|undefined}
+     */
+    tz: string | number | undefined;
+    private isNthWeekdayOfMonth;
+    private fromDate;
+    ms: number;
+    second: number;
+    minute: number;
+    hour: number;
+    day: number;
+    month: number;
+    year: number;
+    private fromCronDate;
+    private apply;
+    private fromString;
+    private findNext;
+    private recurse;
+    /**
+     * Increment to next run time
+     * @public
+     *
+     * @param {string} pattern - The pattern used to increment current state
+     * @param {CronOptions} options - Cron options used for incrementing
+     * @param {boolean} [hasPreviousRun] - If this run should adhere to minimum interval
+     * @return {CronDate|null} - Returns itthis for chaining, or null if increment wasnt possible
+     */
+    public increment(pattern: string, options: CronOptions, hasPreviousRun?: boolean): CronDate | null;
+    /**
+     * Convert current state back to a javascript Date()
+     * @public
+     *
+     * @param {boolean} internal - If this is an internal call
+     * @returns {Date}
+     */
+    public getDate(internal: boolean): Date;
+    /**
+     * Convert current state back to a javascript Date() and return UTC milliseconds
+     * @public
+     *
+     * @returns {Date}
+     */
+    public getTime(): Date;
+}
+/**
+ * An array containing all named cron jobs.
+ *
+ * @constant
+ * @type {Cron[]}
+ */
+declare const scheduledJobs: Cron[];
+type TimePoint = {
+    /**
+     * - 1970--
+     */
+    y: number;
+    /**
+     * - 1-12
+     */
+    m: number;
+    /**
+     * - 1-31
+     */
+    d: number;
+    /**
+     * - 0-24
+     */
+    h: number;
+    /**
+     * - 0-60 Minute
+     */
+    i: number;
+    /**
+     * - 0-60
+     */
+    s: number;
+    /**
+     * - Time zone in IANA database format 'Europe/Stockholm'
+     */
+    tz: string;
+};
+type CatchCallbackFn = (e: unknown, job: Cron) => any;
+type ProtectCallbackFn = (job: Cron) => any;
+/**
+ * Name for each part of the cron pattern
+ */
+type CronPatternPart = ("second" | "minute" | "hour" | "day" | "month" | "dayOfWeek");
+/**
+ * Offset, 0 or -1.
+ *
+ * 0 offset is used for seconds,minutes and hours as they start on 1.
+ * -1 on days and months, as they start on 0
+ */
+type CronIndexOffset = number;
diff --git a/node_modules/croner/.9fdeff6f8fd7ddd7-00000006.README.md b/.9fdeff6f8fd7ddd7-00000006.README.md
new file mode 100644
index 0000000000000000000000000000000000000000..f630cbf4ad708eaa0678faf4ff85554c7594d5a4
--- /dev/null
+++ b/.9fdeff6f8fd7ddd7-00000006.README.md
@@ -0,0 +1,309 @@
+<p align="center">
+<img src="https://cdn.jsdelivr.net/gh/hexagon/croner@master/croner.png" alt="Croner" width="150" height="150"><br>
+Trigger functions or evaluate cron expressions in JavaScript or TypeScript. No dependencies. All features. Node. Deno. Bun. Browser. <br><br>Try it live on <a href="https://jsfiddle.net/hexag0n/hoa8kwsb/">jsfiddle</a>, and check out the full documentation on <a href="https://croner.56k.guru">croner.56k.guru</a>.<br>
+</p>
+
+# Croner - Cron for JavaScript and TypeScript
+
+[![npm version](https://badge.fury.io/js/croner.svg)](https://badge.fury.io/js/croner) [![Codacy Badge](https://app.codacy.com/project/badge/Grade/4978bdbf495941c087ecb32b120f28ff)](https://www.codacy.com/gh/Hexagon/croner/dashboard?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=Hexagon/croner&amp;utm_campaign=Badge_Grade) [![NPM Downloads](https://img.shields.io/npm/dw/croner.svg)](https://www.npmjs.org/package/croner)
+![No dependencies](https://img.shields.io/badge/dependencies-none-brightgreen) [![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/Hexagon/croner/blob/master/LICENSE)
+
+*   Trigger functions in JavaScript using [Cron](https://en.wikipedia.org/wiki/Cron#CRON_expression) syntax.
+*   Evaluate cron expressions and get a list of upcoming run times.
+*   Uses Vixie-cron [pattern](#pattern), with additional features such as `L` for last day and weekday of month and `#` for nth weekday of month.
+*   Works in Node.js >=18 (both require and import), Deno >=1.16 and Bun >=1.0.0.
+*   Works in browsers as standalone, UMD or ES-module.
+*   Target different [time zones](https://croner.56k.guru/usage/examples/#time-zone).
+*   Built-in [overrun protection](https://croner.56k.guru/usage/examples/#overrun-protection)
+*   Built-in [error handling](https://croner.56k.guru/usage/examples/#error-handling)
+*   Includes [TypeScript](https://www.typescriptlang.org/) typings.
+*   Support for asynchronous functions.
+*   Pause, resume, or stop execution after a task is scheduled.
+*   Operates in-memory, with no need for a database or configuration files.
+*   Zero dependencies.
+
+Quick examples:
+
+```javascript
+// Basic: Run a function at the interval defined by a cron expression
+const job = Cron('*/5 * * * * *', () => {
+	console.log('This will run every fifth second');
+});
+
+// Enumeration: What dates do the next 100 sundays occur on?
+const nextSundays = Cron('0 0 0 * * 7').nextRuns(100);
+console.log(nextSundays);
+
+// Days left to a specific date
+const msLeft = Cron('59 59 23 24 DEC *').nextRun() - new Date();
+console.log(Math.floor(msLeft/1000/3600/24) + " days left to next christmas eve");
+
+// Run a function at a specific date/time using a non-local timezone (time is ISO 8601 local time)
+// This will run 2024-01-23 00:00:00 according to the time in Asia/Kolkata
+Cron('2024-01-23T00:00:00', { timezone: 'Asia/Kolkata' }, () => { console.log('Yay!') });
+
+```
+
+More [examples](https://croner.56k.guru/usage/examples/)...
+
+## Installation
+
+Full documentation on installation and usage is found at <https://croner.56k.guru>
+
+> **Note**
+> If you are migrating from a different library such as `cron` or `node-cron`, or upgrading from a older version of croner, see the [migration section](https://croner.56k.guru/migration/) of the manual.
+
+Install croner using your favorite package manager or CDN. then include it in you project: 
+
+Using Node.js or Bun
+
+```javascript
+// ESM Import ...
+import { Cron } from "croner";
+
+// ... or CommonJS Require, destructure to add type hints
+const { Cron } = require("croner");
+```
+
+Using Deno
+
+```typescript
+// From deno.land/x
+import { Cron } from "https://deno.land/x/croner@8.0.2/dist/croner.js";
+
+// ... or jsr.io
+import { Cron } from "jsr:@hexagon/croner@8.0.2";
+```
+
+In a webpage using the UMD-module
+
+```html
+<script src="https://cdn.jsdelivr.net/npm/croner@8/dist/croner.umd.min.js"></script>
+```
+
+## Documentation
+
+### Signature
+
+Cron takes three arguments
+
+*   [pattern](#pattern)
+*   [options](#options) (optional) 
+*   scheduleds function (optional)
+
+```javascript
+// Parameters
+// - First: Cron pattern, js date object (fire once), or ISO 8601 time string (fire once)
+// - Second: Options (optional)
+// - Third: Function run trigger (optional)
+const job = Cron("* * * * * *", { maxRuns: 1 }, () => {} );
+
+// If function is omitted in constructor, it can be scheduled later
+job.schedule(job, /* optional */ context) => {});
+```
+
+The job will be sceduled to run at next matching time unless you supply option `{ paused: true }`. The `Cron(...)` constructor will return a Cron instance, later called `job`, which have a couple of methods and properties listed below.
+
+#### Status
+
+```javascript
+job.nextRun( /*optional*/ startFromDate );	// Get a Date object representing the next run.
+job.nextRuns(10, /*optional*/ startFromDate ); // Get an array of Dates, containing the next n runs.
+job.msToNext( /*optional*/ startFromDate ); // Get the milliseconds left until the next execution.
+job.currentRun(); 		// Get a Date object showing when the current (or last) run was started.
+job.previousRun( ); 		// Get a Date object showing when the previous job was started.
+
+job.isRunning(); 	// Indicates if the job is scheduled and not paused or killed (true or false).
+job.isStopped(); 	// Indicates if the job is permanently stopped using `stop()` (true or false).
+job.isBusy(); 		// Indicates if the job is currently busy doing work (true or false).
+
+job.getPattern(); 	// Returns the original pattern string
+```
+
+#### Control functions
+
+```javascript
+job.trigger();		// Force a trigger instantly
+job.pause();		// Pause trigger
+job.resume();		// Resume trigger
+job.stop();		// Stop the job completely. It is not possible to resume after this.
+				// Note that this also removes named jobs from the exported `scheduledJobs` array.
+```
+
+#### Properties
+
+```javascript
+job.name 			// Optional job name, populated if a name were passed to options
+```
+
+#### Options
+
+| Key          | Default value  | Data type      | Remarks                               |
+|--------------|----------------|----------------|---------------------------------------|
+| name         | undefined      | String         | If you specify a name for the job, Croner will keep a reference to the job in the exported array `scheduledJobs`. The reference will be removed on `.stop()`. |
+| maxRuns      | Infinite       | Number         |                                       |
+| catch	       | false          | Boolean\|Function        | Catch unhandled errors in triggered function. Passing `true` will silently ignore errors. Passing a callback function will trigger this callback on error. |
+| timezone     | undefined      | String         | Timezone in Europe/Stockholm format   |
+| startAt      | undefined      | String         | ISO 8601 formatted datetime (2021-10-17T23:43:00)<br>in local time (according to timezone parameter if passed) |
+| stopAt       | undefined      | String         | ISO 8601 formatted datetime (2021-10-17T23:43:00)<br>in local time (according to timezone parameter if passed) |
+| interval     | 0              | Number         | Minimum number of seconds between triggers. |
+| paused       | false          | Boolean        | If the job should be paused from start. |
+| context      | undefined      | Any            | Passed as the second parameter to triggered function |
+| legacyMode   | true           | boolean        | Combine day-of-month and day-of-week using true = OR, false = AND |
+| unref        | false          | boolean        | Setting this to true unrefs the internal timer, which allows the process to exit even if a cron job is running. |
+| utcOffset    | undefined      | number        | Schedule using a specific utc offset in minutes. This does not take care of daylight savings time, you probably want to use option `timezone` instead. |
+| protect      | undefined      | boolean\|Function | Enabled over-run protection. Will block new triggers as long as an old trigger is in progress. Pass either `true` or a callback function to enable |
+
+> **Warning**
+> Unreferencing timers (option `unref`) is only supported by Node.js and Deno. 
+> Browsers have not yet implemented this feature, and it does not make sense to use it in a browser environment.
+
+#### Pattern
+
+The expressions used by Croner are very similar to those of Vixie Cron, but with a few additions and changes as outlined below:
+
+```javascript
+// ┌──────────────── (optional) second (0 - 59)
+// │ ┌────────────── minute (0 - 59)
+// │ │ ┌──────────── hour (0 - 23)
+// │ │ │ ┌────────── day of month (1 - 31)
+// │ │ │ │ ┌──────── month (1 - 12, JAN-DEC)
+// │ │ │ │ │ ┌────── day of week (0 - 6, SUN-Mon) 
+// │ │ │ │ │ │       (0 to 6 are Sunday to Saturday; 7 is Sunday, the same as 0)
+// │ │ │ │ │ │
+// * * * * * *
+```
+
+*   Croner expressions have the following additional modifiers:
+	-   *?*: The question mark is substituted with the time of initialization. For example, ? ? * * * * would be substituted with 25 8 * * * * if the time is <any hour>:08:25 at the time of new Cron('? ? * * * *', <...>). The question mark can be used in any field.
+	-   *L*: The letter 'L' can be used in the day of the month field to indicate the last day of the month. When used in the day of the week field in conjunction with the # character, it denotes the last specific weekday of the month. For example, `5#L` represents the last Friday of the month.
+	-	*#*: The # character specifies the "nth" occurrence of a particular day within a month. For example, supplying 
+	`5#2` in the day of week field signifies the second Friday of the month. This can be combined with ranges and supports day names. For instance, MON-FRI#2 would match the Monday through Friday of the second week of the month.
+
+*   Croner allows you to pass a JavaScript Date object or an ISO 8601 formatted string as a pattern. The scheduled function will trigger at the specified date/time and only once. If you use a timezone different from the local timezone, you should pass the ISO 8601 local time in the target location and specify the timezone using the options (2nd parameter).
+
+*   Croner also allows you to change how the day-of-week and day-of-month conditions are combined. By default, Croner (and Vixie cron) will trigger when either the day-of-month OR the day-of-week conditions match. For example, `0 20 1 * MON` will trigger on the first of the month as well as each Monday. If you want to use AND (so that it only triggers on Mondays that are also the first of the month), you can pass `{ legacyMode: false }`. For more information, see issue [#53](https://github.com/Hexagon/croner/issues/53).
+
+| Field        | Required | Allowed values | Allowed special characters | Remarks                               |
+|--------------|----------|----------------|----------------------------|---------------------------------------|
+| Seconds      | Optional | 0-59           | * , - / ?                  |                                       |
+| Minutes      | Yes      | 0-59           | * , - / ?                  |                                       |
+| Hours        | Yes      | 0-23           | * , - / ?                  |                                       |
+| Day of Month | Yes      | 1-31           | * , - / ? L                |                                       |
+| Month        | Yes      | 1-12 or JAN-DEC| * , - / ?                  |                                       |
+| Day of Week  | Yes      | 0-7 or SUN-MON | * , - / ? L #               | 0 to 6 are Sunday to Saturday<br>7 is Sunday, the same as 0<br># is used to specify nth occurrence of a weekday            |
+
+> **Note**
+> Weekday and month names are case-insensitive. Both `MON` and `mon` work.
+> When using `L` in the Day of Week field, it affects all specified weekdays. For example, `5-6#L` means the last Friday and Saturday in the month."
+> The # character can be used to specify the "nth" weekday of the month. For example, 5#2 represents the second Friday of the month.
+
+It is also possible to use the following "nicknames" as pattern.
+
+| Nickname | Description |
+| -------- | ----------- |
+| \@yearly | Run once a year, ie.  "0 0 1 1 *". |
+| \@annually | Run once a year, ie.  "0 0 1 1 *". |
+| \@monthly | Run once a month, ie. "0 0 1 * *". |
+| \@weekly | Run once a week, ie.  "0 0 * * 0". |
+| \@daily | Run once a day, ie.   "0 0 * * *". |
+| \@hourly | Run once an hour, ie. "0 * * * *". |
+
+## Why another JavaScript cron implementation
+
+Because the existing ones are not good enough. They have serious bugs, use bloated dependencies, do not work in all environments, and/or simply do not work as expected.
+
+|                           | croner              | cronosjs            | node-cron | cron                      | node-schedule       |
+|---------------------------|:-------------------:|:-------------------:|:---------:|:-------------------------:|:-------------------:|
+| **Platforms**                                                                                                                        |
+| Node.js (CommonJS)                   |          ✓          |          ✓          |     ✓     |           ✓               |          ✓          |
+| Browser (ESMCommonJS)                  |          ✓          |          ✓          |           |                           |                     |
+| Deno (ESM)                     |          ✓          |                     |           |                           |                     |
+| **Features**                                                                                                                        |
+| Over-run protection  |          ✓          |                    |              |                            |                    |
+| Error handling  |          ✓          |                    |              |                            |          ✓          |
+| Typescript typings        |          ✓          |         ✓            |           |            ✓              |                     |
+| Unref timers (optional)    |          ✓          |                     |                     |          ✓          |                     |
+| dom-OR-dow                |          ✓          |          ✓          |     ✓     |           ✓               |          ✓          |
+| dom-AND-dow (optional)    |          ✓          |                     |           |                           |                     |
+| Next run                  |          ✓          |          ✓          |           |           ✓              |           ✓         |
+| Next n runs               |          ✓          |          ✓          |           |           ✓               |                     |
+| Timezone                  |          ✓          |           ✓         |     ✓       |        ✓                   |         ✓            |
+| Minimum interval          |          ✓          |                     |              |                            |                      |
+| Controls (stop/resume)    |          ✓          |           ✓         |     ✓        |        ✓                   |         ✓           |   
+| Range (0-13)   |          ✓          |          ✓          |     ✓        |        ✓                   |         ✓           |
+| Stepping (*/5)   |          ✓          |          ✓          |     ✓        |        ✓                   |         ✓           |
+| Last day of month (L)  |          ✓          |          ✓          |              |                            |                    |
+| Nth weekday of month (#)     |          ✓          |           ✓          |           |                           |                     |
+
+<details>
+  <summary>In depth comparison of various libraries</summary>
+  
+|                           | croner              | cronosjs            | node-cron | cron                      | node-schedule       |
+|---------------------------|:-------------------:|:-------------------:|:---------:|:-------------------------:|:-------------------:|
+| **Size**                                                                                                                        |
+| Minified size (KB)        | 17.0                | 14.9            | 15.2      | 85.4 :warning:                      | 100.5 :warning:                |
+| Bundlephobia  minzip (KB) | 5.0                 | 5.1                 | 5.7       |                   25.8 | 29.2 :warning:             |
+| Dependencies              |                   0 |                   0 |         1 |                         1 |                   3 :warning: |
+| **Popularity**                                                                                                                        |
+| Downloads/week [^1]        | 2019K                | 31K                 | 447K      | 1366K                     | 1046K                |
+| **Quality**                                                                                                                        |
+| Issues [^1]                |                   0 |                   2 |   133 :warning: |                 13 |    145 :warning: |
+| Code coverage              |                   99%  | 98%                    | 100%                | 81%                              | 94%                 |
+| **Performance**                                                                                                                        |
+| Ops/s `1 2 3 4 5 6`         | 160 651                    | 55 593                    | N/A :x:          | 6 313 :warning:      | 2 726 :warning:                    |
+| Ops/s `0 0 0 29 2 *`         | 176 714                    | 67 920                    | N/A :x:          | 3 104 :warning:      | 737 :warning:                    |
+| **Tests**                 | **11/11**             | **10/11**            | **0/11** [^4] :question:    |  **7/11** :warning:                  | **9/11**             |
+
+> **Note**
+> *   Table last updated at 2023-10-10
+> *   node-cron has no interface to predict when the function will run, so tests cannot be carried out.
+> *   All tests and benchmarks were carried out using [https://github.com/Hexagon/cron-comparison](https://github.com/Hexagon/cron-comparison)
+
+[^1]: As of 2023-10-10
+[^2]: Requires support for L-modifier
+[^3]: In dom-AND-dow mode, only supported by croner at the moment.
+[^4]: Node-cron has no way of showing next run time.
+
+</details>
+
+## Development
+
+### Master branch
+
+![Node.js CI](https://github.com/Hexagon/croner/workflows/Node.js%20CI/badge.svg?branch=master) ![Deno CI](https://github.com/Hexagon/croner/workflows/Deno%20CI/badge.svg?branch=master) ![Bun CI](https://github.com/Hexagon/croner/workflows/Bun%20CI/badge.svg?branch=master) 
+
+This branch contains the latest stable code, released on npm's default channel `latest`. You can install the latest stable revision by running the command below.
+
+```
+npm install croner --save
+```
+
+### Dev branch
+
+![Node.js CI](https://github.com/Hexagon/croner/workflows/Node.js%20CI/badge.svg?branch=dev) ![Deno CI](https://github.com/Hexagon/croner/workflows/Deno%20CI/badge.svg?branch=dev) ![Bun CI](https://github.com/Hexagon/croner/workflows/Bun%20CI/badge.svg?branch=dev) 
+
+This branch contains code currently being tested, and is released at channel `dev` on npm. You can install the latest revision of the development branch by running the command below.
+
+```
+npm install croner@dev
+```
+
+> **Warning**
+> Expect breaking changes if you do not pin to a specific version.
+
+A list of fixes and features currently released in the `dev` branch is available [here](https://github.com/Hexagon/croner/issues?q=is%3Aopen+is%3Aissue+label%3Areleased-in-dev)
+
+## Contributing & Support
+
+Croner is founded and actively maintained by Hexagon. If you find value in Croner and want to contribute:
+
+- Code Contributions: See our [Contribution Guide](https://croner.56k.guru/contributing/) for details on how to contribute code.
+
+- Sponsorship and Donations: See [github.com/sponsors/hexagon](https://github.com/sponsors/hexagon)
+
+Your trust, support, and contributions drive the project. Every bit, irrespective of its size, is deeply appreciated.
+
+## License
+
+MIT License
\ No newline at end of file
diff --git a/node_modules/croner/.d7ffff4fffe3b791-00000001.croner.min.cjs b/.d7ffff4fffe3b791-00000001.croner.min.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..8ac4ca1984e2af5a8c099b1756dd0c5f2454d7dd
--- /dev/null
+++ b/.d7ffff4fffe3b791-00000001.croner.min.cjs
@@ -0,0 +1 @@
+"use strict";function minitz(y,m,d,h,i,s,tz,throwOnInvalid){return minitz.fromTZ(minitz.tp(y,m,d,h,i,s,tz),throwOnInvalid)}minitz.fromTZISO=(localTimeStr,tz,throwOnInvalid)=>{return minitz.fromTZ(parseISOLocal(localTimeStr,tz),throwOnInvalid)};minitz.fromTZ=function(tp,throwOnInvalid){const inDate=new Date(Date.UTC(tp.y,tp.m-1,tp.d,tp.h,tp.i,tp.s)),offset=getTimezoneOffset(tp.tz,inDate),dateGuess=new Date(inDate.getTime()-offset),dateOffsGuess=getTimezoneOffset(tp.tz,dateGuess);if(dateOffsGuess-offset===0){return dateGuess}else{const dateGuess2=new Date(inDate.getTime()-dateOffsGuess),dateOffsGuess2=getTimezoneOffset(tp.tz,dateGuess2);if(dateOffsGuess2-dateOffsGuess===0){return dateGuess2}else if(!throwOnInvalid&&dateOffsGuess2-dateOffsGuess>0){return dateGuess2}else if(!throwOnInvalid){return dateGuess}else{throw new Error("Invalid date passed to fromTZ()")}}};minitz.toTZ=function(d,tzStr){const localDateString=d.toLocaleString("en-US",{timeZone:tzStr}).replace(/[\u202f]/," ");const td=new Date(localDateString);return{y:td.getFullYear(),m:td.getMonth()+1,d:td.getDate(),h:td.getHours(),i:td.getMinutes(),s:td.getSeconds(),tz:tzStr}};minitz.tp=(y,m,d,h,i,s,tz)=>{return{y:y,m:m,d:d,h:h,i:i,s:s,tz:tz}};function getTimezoneOffset(timeZone,date=new Date){const tz=date.toLocaleString("en-US",{timeZone:timeZone,timeZoneName:"shortOffset"}).split(" ").slice(-1)[0];const dateString=date.toLocaleString("en-US").replace(/[\u202f]/," ");return Date.parse(`${dateString} GMT`)-Date.parse(`${dateString} ${tz}`)}function parseISOLocal(dtStr,tz){const pd=new Date(Date.parse(dtStr));if(isNaN(pd)){throw new Error("minitz: Invalid ISO8601 passed to parser.")}const stringEnd=dtStr.substring(9);if(dtStr.includes("Z")||stringEnd.includes("-")||stringEnd.includes("+")){return minitz.tp(pd.getUTCFullYear(),pd.getUTCMonth()+1,pd.getUTCDate(),pd.getUTCHours(),pd.getUTCMinutes(),pd.getUTCSeconds(),"Etc/UTC")}else{return minitz.tp(pd.getFullYear(),pd.getMonth()+1,pd.getDate(),pd.getHours(),pd.getMinutes(),pd.getSeconds(),tz)}}minitz.minitz=minitz;function CronOptions(options){if(options===void 0){options={}}delete options.name;options.legacyMode=options.legacyMode===void 0?true:options.legacyMode;options.paused=options.paused===void 0?false:options.paused;options.maxRuns=options.maxRuns===void 0?Infinity:options.maxRuns;options.catch=options.catch===void 0?false:options.catch;options.interval=options.interval===void 0?0:parseInt(options.interval,10);options.utcOffset=options.utcOffset===void 0?void 0:parseInt(options.utcOffset,10);options.unref=options.unref===void 0?false:options.unref;if(options.startAt){options.startAt=new CronDate(options.startAt,options.timezone)}if(options.stopAt){options.stopAt=new CronDate(options.stopAt,options.timezone)}if(options.interval!==null){if(isNaN(options.interval)){throw new Error("CronOptions: Supplied value for interval is not a number")}else if(options.interval<0){throw new Error("CronOptions: Supplied value for interval can not be negative")}}if(options.utcOffset!==void 0){if(isNaN(options.utcOffset)){throw new Error("CronOptions: Invalid value passed for utcOffset, should be number representing minutes offset from UTC.")}else if(options.utcOffset<-870||options.utcOffset>870){throw new Error("CronOptions: utcOffset out of bounds.")}if(options.utcOffset!==void 0&&options.timezone){throw new Error("CronOptions: Combining 'utcOffset' with 'timezone' is not allowed.")}}if(options.unref!==true&&options.unref!==false){throw new Error("CronOptions: Unref should be either true, false or undefined(false).")}return options}const LAST_OCCURRENCE=32;const ANY_OCCURRENCE=1|2|4|8|16|LAST_OCCURRENCE;const OCCURRENCE_BITMASKS=[1,2,4,16,16];function CronPattern(pattern,timezone){this.pattern=pattern;this.timezone=timezone;this.second=Array(60).fill(0);this.minute=Array(60).fill(0);this.hour=Array(24).fill(0);this.day=Array(31).fill(0);this.month=Array(12).fill(0);this.dayOfWeek=Array(7).fill(0);this.lastDayOfMonth=false;this.starDOM=false;this.starDOW=false;this.parse()}CronPattern.prototype.parse=function(){if(!(typeof this.pattern==="string"||this.pattern.constructor===String)){throw new TypeError("CronPattern: Pattern has to be of type string.")}if(this.pattern.indexOf("@")>=0)this.pattern=this.handleNicknames(this.pattern).trim();const parts=this.pattern.replace(/\s+/g," ").split(" ");if(parts.length<5||parts.length>6){throw new TypeError("CronPattern: invalid configuration format ('"+this.pattern+"'), exactly five or six space separated parts are required.")}if(parts.length===5){parts.unshift("0")}if(parts[3].indexOf("L")>=0){parts[3]=parts[3].replace("L","");this.lastDayOfMonth=true}if(parts[3]=="*"){this.starDOM=true}if(parts[4].length>=3)parts[4]=this.replaceAlphaMonths(parts[4]);if(parts[5].length>=3)parts[5]=this.replaceAlphaDays(parts[5]);if(parts[5]=="*"){this.starDOW=true}if(this.pattern.indexOf("?")>=0){const initDate=new CronDate(new Date,this.timezone).getDate(true);parts[0]=parts[0].replace("?",initDate.getSeconds());parts[1]=parts[1].replace("?",initDate.getMinutes());parts[2]=parts[2].replace("?",initDate.getHours());if(!this.starDOM)parts[3]=parts[3].replace("?",initDate.getDate());parts[4]=parts[4].replace("?",initDate.getMonth()+1);if(!this.starDOW)parts[5]=parts[5].replace("?",initDate.getDay())}this.throwAtIllegalCharacters(parts);this.partToArray("second",parts[0],0,1);this.partToArray("minute",parts[1],0,1);this.partToArray("hour",parts[2],0,1);this.partToArray("day",parts[3],-1,1);this.partToArray("month",parts[4],-1,1);this.partToArray("dayOfWeek",parts[5],0,ANY_OCCURRENCE);if(this.dayOfWeek[7]){this.dayOfWeek[0]=this.dayOfWeek[7]}};CronPattern.prototype.partToArray=function(type,conf,valueIndexOffset,defaultValue){const arr=this[type];const lastDayOfMonth=type==="day"&&this.lastDayOfMonth;if(conf===""&&!lastDayOfMonth)throw new TypeError("CronPattern: configuration entry "+type+" ("+conf+") is empty, check for trailing spaces.");if(conf==="*")return arr.fill(defaultValue);const split=conf.split(",");if(split.length>1){for(let i=0;i<split.length;i++){this.partToArray(type,split[i],valueIndexOffset,defaultValue)}}else if(conf.indexOf("-")!==-1&&conf.indexOf("/")!==-1){this.handleRangeWithStepping(conf,type,valueIndexOffset,defaultValue)}else if(conf.indexOf("-")!==-1){this.handleRange(conf,type,valueIndexOffset,defaultValue)}else if(conf.indexOf("/")!==-1){this.handleStepping(conf,type,valueIndexOffset,defaultValue)}else if(conf!==""){this.handleNumber(conf,type,valueIndexOffset,defaultValue)}};CronPattern.prototype.throwAtIllegalCharacters=function(parts){for(let i=0;i<parts.length;i++){const reValidCron=i===5?/[^/*0-9,\-#L]+/:/[^/*0-9,-]+/;if(reValidCron.test(parts[i])){throw new TypeError("CronPattern: configuration entry "+i+" ("+parts[i]+") contains illegal characters.")}}};CronPattern.prototype.handleNumber=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const i=parseInt(result[0],10)+valueIndexOffset;if(isNaN(i)){throw new TypeError("CronPattern: "+type+" is not a number: '"+conf+"'")}this.setPart(type,i,result[1]||defaultValue)};CronPattern.prototype.setPart=function(part,index,value){if(!Object.prototype.hasOwnProperty.call(this,part)){throw new TypeError("CronPattern: Invalid part specified: "+part)}if(part==="dayOfWeek"){if(index===7)index=0;if((index<0||index>6)&&index!=="L"){throw new RangeError("CronPattern: Invalid value for dayOfWeek: "+index)}this.setNthWeekdayOfMonth(index,value);return}if(part==="second"||part==="minute"){if(index<0||index>=60){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}else if(part==="hour"){if(index<0||index>=24){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}else if(part==="day"){if(index<0||index>=31){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}else if(part==="month"){if(index<0||index>=12){throw new RangeError("CronPattern: Invalid value for "+part+": "+index)}}this[part][index]=value};CronPattern.prototype.handleRangeWithStepping=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const matches=result[0].match(/^(\d+)-(\d+)\/(\d+)$/);if(matches===null)throw new TypeError("CronPattern: Syntax error, illegal range with stepping: '"+conf+"'");let[,lower,upper,steps]=matches;lower=parseInt(lower,10)+valueIndexOffset;upper=parseInt(upper,10)+valueIndexOffset;steps=parseInt(steps,10);if(isNaN(lower))throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");if(isNaN(upper))throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");if(isNaN(steps))throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");if(steps===0)throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");if(steps>this[type].length)throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part ("+this[type].length+")");if(lower>upper)throw new TypeError("CronPattern: From value is larger than to value: '"+conf+"'");for(let i=lower;i<=upper;i+=steps){this.setPart(type,i,result[1]||defaultValue)}};CronPattern.prototype.extractNth=function(conf,type){let rest=conf;let nth;if(rest.includes("#")){if(type!=="dayOfWeek"){throw new Error("CronPattern: nth (#) only allowed in day-of-week field")}nth=rest.split("#")[1];rest=rest.split("#")[0]}return[rest,nth]};CronPattern.prototype.handleRange=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const split=result[0].split("-");if(split.length!==2){throw new TypeError("CronPattern: Syntax error, illegal range: '"+conf+"'")}const lower=parseInt(split[0],10)+valueIndexOffset,upper=parseInt(split[1],10)+valueIndexOffset;if(isNaN(lower)){throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)")}else if(isNaN(upper)){throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)")}if(lower>upper){throw new TypeError("CronPattern: From value is larger than to value: '"+conf+"'")}for(let i=lower;i<=upper;i++){this.setPart(type,i,result[1]||defaultValue)}};CronPattern.prototype.handleStepping=function(conf,type,valueIndexOffset,defaultValue){const result=this.extractNth(conf,type);const split=result[0].split("/");if(split.length!==2){throw new TypeError("CronPattern: Syntax error, illegal stepping: '"+conf+"'")}let start=0;if(split[0]!=="*"){start=parseInt(split[0],10)+valueIndexOffset}const steps=parseInt(split[1],10);if(isNaN(steps))throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");if(steps===0)throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");if(steps>this[type].length)throw new TypeError("CronPattern: Syntax error, max steps for part is ("+this[type].length+")");for(let i=start;i<this[type].length;i+=steps){this.setPart(type,i,result[1]||defaultValue)}};CronPattern.prototype.replaceAlphaDays=function(conf){return conf.replace(/-sun/gi,"-7").replace(/sun/gi,"0").replace(/mon/gi,"1").replace(/tue/gi,"2").replace(/wed/gi,"3").replace(/thu/gi,"4").replace(/fri/gi,"5").replace(/sat/gi,"6")};CronPattern.prototype.replaceAlphaMonths=function(conf){return conf.replace(/jan/gi,"1").replace(/feb/gi,"2").replace(/mar/gi,"3").replace(/apr/gi,"4").replace(/may/gi,"5").replace(/jun/gi,"6").replace(/jul/gi,"7").replace(/aug/gi,"8").replace(/sep/gi,"9").replace(/oct/gi,"10").replace(/nov/gi,"11").replace(/dec/gi,"12")};CronPattern.prototype.handleNicknames=function(pattern){const cleanPattern=pattern.trim().toLowerCase();if(cleanPattern==="@yearly"||cleanPattern==="@annually"){return"0 0 1 1 *"}else if(cleanPattern==="@monthly"){return"0 0 1 * *"}else if(cleanPattern==="@weekly"){return"0 0 * * 0"}else if(cleanPattern==="@daily"){return"0 0 * * *"}else if(cleanPattern==="@hourly"){return"0 * * * *"}else{return pattern}};CronPattern.prototype.setNthWeekdayOfMonth=function(index,nthWeekday){if(nthWeekday==="L"){this["dayOfWeek"][index]=this["dayOfWeek"][index]|LAST_OCCURRENCE}else if(nthWeekday<6&&nthWeekday>0){this["dayOfWeek"][index]=this["dayOfWeek"][index]|OCCURRENCE_BITMASKS[nthWeekday-1]}else if(nthWeekday===ANY_OCCURRENCE){this["dayOfWeek"][index]=ANY_OCCURRENCE}else{throw new TypeError(`CronPattern: nth weekday of of range, should be 1-5 or L. Value: ${nthWeekday}`)}};const DaysOfMonth=[31,28,31,30,31,30,31,31,30,31,30,31];const RecursionSteps=[["month","year",0],["day","month",-1],["hour","day",0],["minute","hour",0],["second","minute",0]];function CronDate(d,tz){this.tz=tz;if(d&&d instanceof Date){if(!isNaN(d)){this.fromDate(d)}else{throw new TypeError("CronDate: Invalid date passed to CronDate constructor")}}else if(d===void 0){this.fromDate(new Date)}else if(d&&typeof d==="string"){this.fromString(d)}else if(d instanceof CronDate){this.fromCronDate(d)}else{throw new TypeError("CronDate: Invalid type ("+typeof d+") passed to CronDate constructor")}}CronDate.prototype.isNthWeekdayOfMonth=function(year,month,day,nth){const date=new Date(Date.UTC(year,month,day));const weekday=date.getUTCDay();let count=0;for(let d=1;d<=day;d++){if(new Date(Date.UTC(year,month,d)).getUTCDay()===weekday){count++}}if(nth&ANY_OCCURRENCE&&OCCURRENCE_BITMASKS[count-1]&nth){return true}if(nth&LAST_OCCURRENCE){const daysInMonth=new Date(Date.UTC(year,month+1,0)).getUTCDate();for(let d=day+1;d<=daysInMonth;d++){if(new Date(Date.UTC(year,month,d)).getUTCDay()===weekday){return false}}return true}return false};CronDate.prototype.fromDate=function(inDate){if(this.tz!==void 0){if(typeof this.tz==="number"){this.ms=inDate.getUTCMilliseconds();this.second=inDate.getUTCSeconds();this.minute=inDate.getUTCMinutes()+this.tz;this.hour=inDate.getUTCHours();this.day=inDate.getUTCDate();this.month=inDate.getUTCMonth();this.year=inDate.getUTCFullYear();this.apply()}else{const d=minitz.toTZ(inDate,this.tz);this.ms=inDate.getMilliseconds();this.second=d.s;this.minute=d.i;this.hour=d.h;this.day=d.d;this.month=d.m-1;this.year=d.y}}else{this.ms=inDate.getMilliseconds();this.second=inDate.getSeconds();this.minute=inDate.getMinutes();this.hour=inDate.getHours();this.day=inDate.getDate();this.month=inDate.getMonth();this.year=inDate.getFullYear()}};CronDate.prototype.fromCronDate=function(d){this.tz=d.tz;this.year=d.year;this.month=d.month;this.day=d.day;this.hour=d.hour;this.minute=d.minute;this.second=d.second;this.ms=d.ms};CronDate.prototype.apply=function(){if(this.month>11||this.day>DaysOfMonth[this.month]||this.hour>59||this.minute>59||this.second>59||this.hour<0||this.minute<0||this.second<0){const d=new Date(Date.UTC(this.year,this.month,this.day,this.hour,this.minute,this.second,this.ms));this.ms=d.getUTCMilliseconds();this.second=d.getUTCSeconds();this.minute=d.getUTCMinutes();this.hour=d.getUTCHours();this.day=d.getUTCDate();this.month=d.getUTCMonth();this.year=d.getUTCFullYear();return true}else{return false}};CronDate.prototype.fromString=function(str){if(typeof this.tz==="number"){const inDate=minitz.fromTZISO(str);this.ms=inDate.getUTCMilliseconds();this.second=inDate.getUTCSeconds();this.minute=inDate.getUTCMinutes();this.hour=inDate.getUTCHours();this.day=inDate.getUTCDate();this.month=inDate.getUTCMonth();this.year=inDate.getUTCFullYear();this.apply()}else{return this.fromDate(minitz.fromTZISO(str,this.tz))}};CronDate.prototype.findNext=function(options,target,pattern,offset){const originalTarget=this[target];let lastDayOfMonth;if(pattern.lastDayOfMonth){if(this.month!==1){lastDayOfMonth=DaysOfMonth[this.month]}else{lastDayOfMonth=new Date(Date.UTC(this.year,this.month+1,0,0,0,0,0)).getUTCDate()}}const fDomWeekDay=!pattern.starDOW&&target=="day"?new Date(Date.UTC(this.year,this.month,1,0,0,0,0)).getUTCDay():undefined;for(let i=this[target]+offset;i<pattern[target].length;i++){let match=pattern[target][i];if(target==="day"&&pattern.lastDayOfMonth&&i-offset==lastDayOfMonth){match=true}if(target==="day"&&!pattern.starDOW){let dowMatch=pattern.dayOfWeek[(fDomWeekDay+(i-offset-1))%7];if(dowMatch&&dowMatch&ANY_OCCURRENCE){dowMatch=this.isNthWeekdayOfMonth(this.year,this.month,i-offset,dowMatch)}else if(dowMatch){throw new Error(`CronDate: Invalid value for dayOfWeek encountered. ${dowMatch}`)}if(options.legacyMode&&!pattern.starDOM){match=match||dowMatch}else{match=match&&dowMatch}}if(match){this[target]=i-offset;return originalTarget!==this[target]?2:1}}return 3};CronDate.prototype.recurse=function(pattern,options,doing){const res=this.findNext(options,RecursionSteps[doing][0],pattern,RecursionSteps[doing][2]);if(res>1){let resetLevel=doing+1;while(resetLevel<RecursionSteps.length){this[RecursionSteps[resetLevel][0]]=-RecursionSteps[resetLevel][2];resetLevel++}if(res===3){this[RecursionSteps[doing][1]]++;this[RecursionSteps[doing][0]]=-RecursionSteps[doing][2];this.apply();return this.recurse(pattern,options,0)}else if(this.apply()){return this.recurse(pattern,options,doing-1)}}doing+=1;if(doing>=RecursionSteps.length){return this}else if(this.year>=3e3){return null}else{return this.recurse(pattern,options,doing)}};CronDate.prototype.increment=function(pattern,options,hasPreviousRun){this.second+=options.interval>1&&hasPreviousRun?options.interval:1;this.ms=0;this.apply();return this.recurse(pattern,options,0)};CronDate.prototype.getDate=function(internal){if(internal||this.tz===void 0){return new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.ms)}else{if(typeof this.tz==="number"){return new Date(Date.UTC(this.year,this.month,this.day,this.hour,this.minute-this.tz,this.second,this.ms))}else{return minitz(this.year,this.month+1,this.day,this.hour,this.minute,this.second,this.tz)}}};CronDate.prototype.getTime=function(){return this.getDate().getTime()};function isFunction(v){return Object.prototype.toString.call(v)==="[object Function]"||"function"===typeof v||v instanceof Function}function unrefTimer(timer){if(typeof Deno!=="undefined"&&typeof Deno.unrefTimer!=="undefined"){Deno.unrefTimer(timer)}else if(timer&&typeof timer.unref!=="undefined"){timer.unref()}}const maxDelay=30*1e3;const scheduledJobs=[];function Cron(pattern,fnOrOptions1,fnOrOptions2){if(!(this instanceof Cron)){return new Cron(pattern,fnOrOptions1,fnOrOptions2)}let options,func;if(isFunction(fnOrOptions1)){func=fnOrOptions1}else if(typeof fnOrOptions1==="object"){options=fnOrOptions1}else if(fnOrOptions1!==void 0){throw new Error("Cron: Invalid argument passed for optionsIn. Should be one of function, or object (options).")}if(isFunction(fnOrOptions2)){func=fnOrOptions2}else if(typeof fnOrOptions2==="object"){options=fnOrOptions2}else if(fnOrOptions2!==void 0){throw new Error("Cron: Invalid argument passed for funcIn. Should be one of function, or object (options).")}this.name=options?options.name:void 0;this.options=CronOptions(options);this._states={kill:false,blocking:false,previousRun:void 0,currentRun:void 0,once:void 0,currentTimeout:void 0,maxRuns:options?options.maxRuns:void 0,paused:options?options.paused:false,pattern:void 0};if(pattern&&(pattern instanceof Date||typeof pattern==="string"&&pattern.indexOf(":")>0)){this._states.once=new CronDate(pattern,this.options.timezone||this.options.utcOffset)}else{this._states.pattern=new CronPattern(pattern,this.options.timezone)}if(this.name){const existing=scheduledJobs.find(j=>j.name===this.name);if(existing){throw new Error("Cron: Tried to initialize new named job '"+this.name+"', but name already taken.")}else{scheduledJobs.push(this)}}if(func!==void 0){this.fn=func;this.schedule()}return this}Cron.prototype.nextRun=function(prev){const next=this._next(prev);return next?next.getDate():null};Cron.prototype.nextRuns=function(n,previous){if(n>this._states.maxRuns){n=this._states.maxRuns}const enumeration=[];let prev=previous||this._states.currentRun;while(n--&&(prev=this.nextRun(prev))){enumeration.push(prev)}return enumeration};Cron.prototype.getPattern=function(){return this._states.pattern?this._states.pattern.pattern:void 0};Cron.prototype.isRunning=function(){const nextRunTime=this.nextRun(this._states.currentRun);const isRunning=!this._states.paused;const isScheduled=this.fn!==void 0;const notIsKilled=!this._states.kill;return isRunning&&isScheduled&&notIsKilled&&nextRunTime!==null};Cron.prototype.isStopped=function(){return this._states.kill};Cron.prototype.isBusy=function(){return this._states.blocking};Cron.prototype.currentRun=function(){return this._states.currentRun?this._states.currentRun.getDate():null};Cron.prototype.previousRun=function(){return this._states.previousRun?this._states.previousRun.getDate():null};Cron.prototype.msToNext=function(prev){prev=prev||new Date;const next=this._next(prev);if(next){return next.getTime()-prev.getTime()}else{return null}};Cron.prototype.stop=function(){this._states.kill=true;if(this._states.currentTimeout){clearTimeout(this._states.currentTimeout)}const jobIndex=scheduledJobs.indexOf(this);if(jobIndex>=0){scheduledJobs.splice(jobIndex,1)}};Cron.prototype.pause=function(){this._states.paused=true;return!this._states.kill};Cron.prototype.resume=function(){this._states.paused=false;return!this._states.kill};Cron.prototype.schedule=function(func){if(func&&this.fn){throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.")}else if(func){this.fn=func}let waitMs=this.msToNext();const target=this.nextRun(this._states.currentRun);if(waitMs===null||waitMs===undefined||isNaN(waitMs)||target===null)return this;if(waitMs>maxDelay){waitMs=maxDelay}this._states.currentTimeout=setTimeout(()=>this._checkTrigger(target),waitMs);if(this._states.currentTimeout&&this.options.unref){unrefTimer(this._states.currentTimeout)}return this};Cron.prototype._trigger=async function(initiationDate){this._states.blocking=true;this._states.currentRun=new CronDate(void 0,this.options.timezone||this.options.utcOffset);if(this.options.catch){try{await this.fn(this,this.options.context)}catch(_e){if(isFunction(this.options.catch)){this.options.catch(_e,this)}}}else{await this.fn(this,this.options.context)}this._states.previousRun=new CronDate(initiationDate,this.options.timezone||this.options.utcOffset);this._states.blocking=false};Cron.prototype.trigger=async function(){await this._trigger()};Cron.prototype._checkTrigger=function(target){const now=new Date,shouldRun=!this._states.paused&&now.getTime()>=target,isBlocked=this._states.blocking&&this.options.protect;if(shouldRun&&!isBlocked){this._states.maxRuns--;this._trigger()}else{if(shouldRun&&isBlocked&&isFunction(this.options.protect)){setTimeout(()=>this.options.protect(this),0)}}this.schedule()};Cron.prototype._next=function(prev){const hasPreviousRun=prev||this._states.currentRun?true:false;prev=new CronDate(prev,this.options.timezone||this.options.utcOffset);if(this.options.startAt&&prev&&prev.getTime()<this.options.startAt.getTime()){prev=this.options.startAt}const nextRun=this._states.once||new CronDate(prev,this.options.timezone||this.options.utcOffset).increment(this._states.pattern,this.options,hasPreviousRun);if(this._states.once&&this._states.once.getTime()<=prev.getTime()){return null}else if(nextRun===null||this._states.maxRuns<=0||this._states.kill||this.options.stopAt&&nextRun.getTime()>=this.options.stopAt.getTime()){return null}else{return nextRun}};Cron.Cron=Cron;Cron.scheduledJobs=scheduledJobs;module.exports=Cron;
\ No newline at end of file
diff --git a/types/croner.d.cts b/types/croner.d.cts
index 9eb643276128e99d17b81149c04ea9798828139a..ec8415b36bbd9135da2426a186d736d387ff9cc1 100644
--- a/types/croner.d.cts
+++ b/types/croner.d.cts
@@ -1,25 +1,28 @@
 export = Cron;
+
+type CronFunction = (self: Cron, context?: any) => unknown;
+
 /**
  * Cron entrypoint
  *
  * @constructor
  * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string
- * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern
- * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern
+ * @param {CronOptions|CronFunction} [fnOrOptions1] - Options or function to be run each iteration of pattern
+ * @param {CronOptions|FuncCronFunctiontion} [fnOrOptions2] - Options or function to be run each iteration of pattern
  * @returns {Cron}
  */
-declare function Cron(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function): Cron;
+declare function Cron(pattern: string | Date, fnOrOptions1?: CronOptions | CronFunction, fnOrOptions2?: CronOptions | CronFunction): Cron;
 declare class Cron {
     /**
      * Cron entrypoint
      *
      * @constructor
      * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string
-     * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern
-     * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern
+     * @param {CronOptions|CronFunction} [fnOrOptions1] - Options or function to be run each iteration of pattern
+     * @param {CronOptions|CronFunction} [fnOrOptions2] - Options or function to be run each iteration of pattern
      * @returns {Cron}
      */
-    constructor(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function);
+    constructor(pattern: string | Date, fnOrOptions1?: CronOptions | CronFunction, fnOrOptions2?: CronOptions | CronFunction);
     /**
      * @public
      * @type {string|undefined} */
@@ -34,7 +37,7 @@ declare class Cron {
      * @private
      */
     private _states;
-    fn: Function | CronOptions;
+    fn: CronFunction | CronOptions;
     /**
      * Find next runtime, based on supplied date. Strips milliseconds.
      *
@@ -126,10 +129,10 @@ declare class Cron {
      * Schedule a new job
      * @public
      *
-     * @param {Function} func - Function to be run each iteration of pattern
+     * @param {CronFunction} func - Function to be run each iteration of pattern
      * @returns {Cron}
      */
-    public schedule(func: Function): Cron;
+    public schedule(func: CronFunction): Cron;
     private _trigger;
     /**
      * Trigger a run manually
diff --git a/types/croner.d.ts b/types/croner.d.ts
index cd54e0f0f5ed21b284510b3bcc7836a5334a9406..8a5f6f58a05d37955e9bd1312962fde2a5cce051 100644
--- a/types/croner.d.ts
+++ b/types/croner.d.ts
@@ -1,3 +1,5 @@
+type CronFunction = (self: Cron, context?: any) => unknown;
+
 export type TimePoint = {
     /**
      * - 1970--
@@ -108,22 +110,22 @@ export type CronIndexOffset = number;
  *
  * @constructor
  * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string
- * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern
- * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern
+ * @param {CronOptions|CronFunction} [fnOrOptions1] - Options or function to be run each iteration of pattern
+ * @param {CronOptions|CronFunction} [fnOrOptions2] - Options or function to be run each iteration of pattern
  * @returns {Cron}
  */
-export function Cron(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function): Cron;
+export function Cron(pattern: string | Date, fnOrOptions1?: CronOptions | CronFunction, fnOrOptions2?: CronOptions | CronFunction): Cron;
 export class Cron {
     /**
      * Cron entrypoint
      *
      * @constructor
      * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string
-     * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern
-     * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern
+     * @param {CronOptions|CronFunction} [fnOrOptions1] - Options or function to be run each iteration of pattern
+     * @param {CronOptions|CronFunction} [fnOrOptions2] - Options or function to be run each iteration of pattern
      * @returns {Cron}
      */
-    constructor(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function);
+    constructor(pattern: string | Date, fnOrOptions1?: CronOptions | CronFunction, fnOrOptions2?: CronOptions | CronFunction);
     /**
      * @public
      * @type {string|undefined} */
@@ -138,7 +140,7 @@ export class Cron {
      * @private
      */
     private _states;
-    fn: Function | CronOptions;
+    fn: CronFunction | CronOptions;
     /**
      * Find next runtime, based on supplied date. Strips milliseconds.
      *
@@ -233,7 +235,7 @@ export class Cron {
      * @param {Function} func - Function to be run each iteration of pattern
      * @returns {Cron}
      */
-    public schedule(func: Function): Cron;
+    public schedule(func: CronFunction): Cron;
     private _trigger;
     /**
      * Trigger a run manually
